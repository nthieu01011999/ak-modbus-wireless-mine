/**
 ******************************************************************************
 * @author: GaoKong
 * @date:   13/08/2016
 ******************************************************************************
**/
#include <malloc.h>
#include <stdlib.h>
#include <string.h>

#include <forward_list>
#include <functional>
#include <iterator>
#include <vector>
#include <deque>
#include <queue>
#include <array>
#include <map>

/* kernel include */
#include "ak.h"
#include "message.h"
#include "timer.h"
#include "fsm.h"

/* driver include */
#include "led.h"
#include "button.h"
#include "flash.h"

/* app include */
#include "app.h"
#include "app_dbg.h"
#include "app_bsp.h"
#include "app_flash.h"
#include "app_non_clear_ram.h"

#include "task_list.h"
#include "task_shell.h"
#include "task_life.h"
#include "task_if.h"
#include "task_uart_if.h"
#include "task_display.h"

/* sys include */
#include "sys_boot.h"
#include "sys_irq.h"
#include "sys_io.h"
#include "sys_ctrl.h"
#include "sys_dbg.h"

/* arduino include */
#include "SPI.h"
#include "WString.h"
#include "HardwareSerial.h"
#include "ArduinoJson.h"

/* common include */
#include "screen_manager.h"

/* ----------------------- Platform includes --------------------------------*/
#include "mw24_nwk.h"
#include "mw24_io_cfg.h"
#include "mw24_eeprom.h"

#include "buzzer.h"

#include "eeprom.h"

/* ----------------------- Json includes ------------------------------------*/
//#include "json.hpp"

using namespace std;

#define MBM_SERIAL_PORT           ( 2 )
#define MBM_SERIAL_BAUDRATE       ( 9600 )

#if defined(RELEASE)
const char* app_run_mode = "RELEASE";
#else
static const char* app_run_mode = "DEBUG";
#endif

const app_info_t app_info { \
	APP_MAGIC_NUMBER, \
			APP_VER, \
};

static boot_app_share_data_t boot_app_share_data;

static void app_power_on_reset();
static void app_start_timer();
static void app_init_state_machine();
static void app_task_init();
static void app_modbus_wireless_init();

/*****************************************************************************/
/* app main function.
 */
/*****************************************************************************/
int main_app() {
	APP_PRINT("App run mode: %s, App version: %d.%d.%d.%d\n" \
			, app_run_mode	\
			, app_info.version[0]	\
			, app_info.version[1]	\
			, app_info.version[2]	\
			, app_info.version[3]);

	sys_soft_reboot_counter++;

	/******************************************************************************
	* init active kernel
	*******************************************************************************/
	ENTRY_CRITICAL();
	task_init();
	task_create((task_t*)app_task_table);
	task_polling_create((task_polling_t*)app_task_polling_table);
	EXIT_CRITICAL();

	/******************************************************************************
	* init applications
	*******************************************************************************/
	/*********************
	* hardware configure *
	**********************/
	/* init watch dog timer */
	sys_ctrl_independent_watchdog_init();	/* 32s */
	sys_ctrl_soft_watchdog_init(200);		/* 20s */

	/* init modbus wireless timer */
	mw24_timer_init(); /* 3ms */

	SPI.begin();

	/* adc peripheral configure */
	io_cfg_adc1();			/* configure adc for thermistor and CT sensor */

	/* adc configure for ct sensor */
	adc_bat_io_cfg();

	/* flash io init */
	flash_io_ctrl_init();

	/*********************
	* software configure *
	**********************/
	/* initial boot object */
	sys_boot_init();

	/* life led init */
	led_init(&led_life, led_life_init, led_life_on, led_life_off);

	ring_buffer_char_init(&ring_buffer_console_rev, buffer_console_rev, BUFFER_CONSOLE_REV_SIZE);

	/* button init */
	button_init(&btn_mode,	10,	BUTTON_MODE_ID,	io_button_mode_init,	io_button_mode_read,	btn_mode_callback);
	button_init(&btn_up,	10,	BUTTON_UP_ID,	io_button_up_init,		io_button_up_read,		btn_up_callback);
	button_init(&btn_down,	10,	BUTTON_DOWN_ID,	io_button_down_init,	io_button_down_read,	btn_down_callback);

	button_enable(&btn_mode);
	button_enable(&btn_up);
	button_enable(&btn_down);

	/* siren init */
	// BUZZER_Init();
	// BUZZER_PlayTones(tones_startup);

	/* init modbus wireless io debug */
	mw24_io_debug_init();

	/* get boot share data */
	flash_read(APP_FLASH_INTTERNAL_SHARE_DATA_SECTOR_1, reinterpret_cast<uint8_t*>(&boot_app_share_data), sizeof(boot_app_share_data_t));
	if (boot_app_share_data.is_power_on_reset == SYS_POWER_ON_RESET) {
		app_power_on_reset();
	}

	/* increase start time */
	fatal_log_t app_fatal_log;
	flash_read(APP_FLASH_AK_DBG_FATAL_LOG_SECTOR, reinterpret_cast<uint8_t*>(&app_fatal_log), sizeof(fatal_log_t));
	app_fatal_log.restart_times ++;
	flash_erase_sector(APP_FLASH_AK_DBG_FATAL_LOG_SECTOR);
	flash_write(APP_FLASH_AK_DBG_FATAL_LOG_SECTOR, reinterpret_cast<uint8_t*>(&app_fatal_log), sizeof(fatal_log_t));

	EXIT_CRITICAL();

	/* start timer for application */
	app_init_state_machine();
	app_start_timer();

	/******************************************************************************
	* app task initial
	*******************************************************************************/
	app_task_init();

	/******************************************************************************
	* app modbus wireless
	*******************************************************************************/
	app_modbus_wireless_init();

	/******************************************************************************
	* run applications
	*******************************************************************************/
#if !defined(IF_LINK_UART_EN)
	sys_ctrl_shell_sw_to_nonblock();
#endif

	return task_run();
}

/*****************************************************************************/
/* polling task can be pushed right here
 * when all ak message queue empty, task_polling_xxx() will be called.
 */
/*****************************************************************************/

void task_polling_console() {
	volatile uint8_t c = 0;

	while (ring_buffer_char_is_empty(&ring_buffer_console_rev) == false) {

		ENTRY_CRITICAL();
		c = ring_buffer_char_get(&ring_buffer_console_rev);
		EXIT_CRITICAL();

#if defined (IF_LINK_UART_EN)
		if (plink_hal_rev_byte(c) == LINK_HAL_IGNORED) {
#endif
			if (shell.index < SHELL_BUFFER_LENGHT - 1) {

				if (c == '\r' || c == '\n') { /* linefeed */

					xputc('\r');
					xputc('\n');

					shell.data[shell.index] = c;
					shell.data[shell.index + 1] = 0;
					task_post_common_msg(AC_TASK_SHELL_ID, AC_SHELL_LOGIN_CMD, (uint8_t*)&shell.data[0], shell.index + 2);

					shell.index = 0;
				}
				else {

					xputc(c);

					if (c == 8 && shell.index) { /* backspace */
						shell.index--;
					}
					else {
						shell.data[shell.index++] = c;
					}
				}
			}
			else {
				LOGIN_PRINT("\nerror: cmd too long, cmd size: %d, try again !\n", SHELL_BUFFER_LENGHT);
				shell.index = 0;
			}
#if defined (IF_LINK_UART_EN)
		}
#endif
	}
}

/*****************************************************************************/
/* app initial function.
 */
/*****************************************************************************/

/* start software timer for application
 * used for app tasks
 */
void app_start_timer() {
	/* start timer to toggle life led */
	timer_set(	AC_TASK_LIFE_ID, \
				AC_LIFE_SYSTEM_CHECK, \
				AC_LIFE_TASK_TIMER_LED_LIFE_INTERVAL, \
				TIMER_PERIODIC);
	timer_set(	AC_TASK_FW_ID, \
				FW_CHECKING_REQ, \
				FW_UPDATE_REQ_INTERVAL, \
				TIMER_ONE_SHOT);
	timer_set(	AC_TASK_DISPLAY_ID, \
				AC_DISPLAY_INITIAL, \
				AC_DISPLAY_INITIAL_INTERVAL, \
				TIMER_ONE_SHOT);
}

/* init state machine for tasks
 * used for app tasks
 */
void app_init_state_machine() {

}

/* send first message to trigger start tasks
 * used for app tasks
 */
void app_task_init() {
	SCREEN_CTOR(&scr_mng_app, scr_startup_handle, &scr_startup);
	task_post_pure_msg(AC_TASK_UART_IF_ID, AC_UART_IF_INIT);
}

void app_modbus_wireless_init() {
	mw24_data_cfg_t data;
	xprintf("Read data %d", mw24_eeprom_read_data_cfg(&data));

	if (mw24_eeprom_read_data_cfg(&data) != MW24_EEPROM_READ_DATA_SUCCESS) {
		data.address = MW24_ADDRESS_RF24_MIN;
		data.number_baudrate = MW24_NUMBER_BAUDRATE_MODBUS_MIN;
		data.channel = MW24_CHANNEL_RF24_MIN;
		mw24_eeprom_write_data_cfg(&data);
	}

	mw24_set_data_cfg(&data);

	mw24_nrf_init();
	mw24_rs485_uart2_init();
}

/*****************************************************************************/
/* app common function
 */
/*****************************************************************************/

/* hardware timer interrupt 10ms
 * used for led, button polling
 */
void sys_irq_timer_10ms() {
	button_timer_polling(&btn_mode);
	button_timer_polling(&btn_up);
	button_timer_polling(&btn_down);
}

/* init non-clear RAM objects
 */
void app_power_on_reset() {
	sys_soft_reboot_counter = 0;
}

void* app_get_boot_share_data() {
	return static_cast<void*>(&boot_app_share_data);
}
/**
 ******************************************************************************
 * @author: GaoKong
 * @date:   13/08/2016
 ******************************************************************************
**/

#ifndef __APP_H__
#define __APP_H__

#ifdef __cplusplus
extern "C"
{
#endif

#include "ak.h"

#include "app_if.h"
#include "app_eeprom.h"
#include "app_data.h"

/*****************************************************************************/
/* SYSTEM task define
 */
/*****************************************************************************/
/* define timer */
/* define signal */
enum {
	SYSTEM_AK_FLASH_UPDATE_REQ = AK_USER_DEFINE_SIG,
};

/*****************************************************************************/
/* FIRMWARE task define
 */
/*****************************************************************************/
/* define timer */
#define FW_PACKED_TIMEOUT_INTERVAL			(5000)
#define FW_UPDATE_REQ_INTERVAL				(5000)

/* define signal */
enum {
	FW_CRENT_APP_FW_INFO_REQ = AK_USER_DEFINE_SIG,
	FW_CRENT_BOOT_FW_INFO_REQ,
	FW_UPDATE_REQ,
	FW_UPDATE_SM_OK,
	FW_TRANSFER_REQ,
	FW_INTERNAL_UPDATE_APP_RES_OK,
	FW_INTERNAL_UPDATE_BOOT_RES_OK,
	FW_SAFE_MODE_RES_OK,
	FW_UPDATE_SM_BUSY,
	FW_PACKED_TIMEOUT,
	FW_CHECKING_REQ
};

/*****************************************************************************/
/*  LIFE task define
 */
/*****************************************************************************/
/* define timer */
#define AC_LIFE_TASK_TIMER_LED_LIFE_INTERVAL		(1000)

/* define signal */
enum {
	AC_LIFE_SYSTEM_CHECK = AK_USER_DEFINE_SIG,
};

/*****************************************************************************/
/*  SHELL task define
 */
/*****************************************************************************/
/* define timer */

/* define signal */
enum {
	AC_SHELL_LOGIN_CMD = AK_USER_DEFINE_SIG,
	AC_SHELL_REMOTE_CMD,
};

/*****************************************************************************/
/*  RF24 task define
 */
/*****************************************************************************/
/* private define */
/* define timer */
/* define signal */
enum {
	AC_RF24_IF_INIT_NETWORK = AK_USER_DEFINE_SIG,
	AC_RF24_IF_PURE_MSG_OUT,
	AC_RF24_IF_COMMON_MSG_OUT,
	AC_RF24_IF_PURE_MSG_IN,
	AC_RF24_IF_COMMON_MSG_IN,
};

/*****************************************************************************/
/* IF task define
 */
/*****************************************************************************/
/* define timer */
/* define signal */
enum {
	AC_IF_PURE_MSG_IN = AK_USER_DEFINE_SIG,
	AC_IF_PURE_MSG_OUT,
	AC_IF_COMMON_MSG_IN,
	AC_IF_COMMON_MSG_OUT,
	AC_IF_DYNAMIC_MSG_IN,
	AC_IF_DYNAMIC_MSG_OUT,
};

/*****************************************************************************/
/* UART_IF task define
 */
/*****************************************************************************/
/* timer signal */
/* define signal */

enum {
	AC_UART_IF_INIT = AK_USER_DEFINE_SIG,
	AC_UART_IF_PURE_MSG_OUT,
	AC_UART_IF_COMMON_MSG_OUT,
	AC_UART_IF_DYNAMIC_MSG_OUT,
	AC_UART_IF_PURE_MSG_IN,
	AC_UART_IF_COMMON_MSG_IN,
	AC_UART_IF_DYNAMIC_MSG_IN,
};

/*****************************************************************************/
/*  LIFE task define
 */
/*****************************************************************************/
/* define timer */
#define AC_DISPLAY_INITIAL_INTERVAL									(100)
#define AC_DISPLAY_STARTUP_INTERVAL									(2000)
#define AC_DISPLAY_LOGO_INTERVAL									(10000)
#define AC_DISPLAY_IDLE_INTERVAL									(10000)
#define AC_DISPLAY_INFORM_INTERVAL									(1300)
#define AC_DISPLAY_LOADING_SETTING_INTERVAL							(2500)
#define AC_DISPLAY_SHOW_IDLE_BALL_MOVING_UPDATE_INTERAL				(150)



/* define signal */
enum {
	AC_DISPLAY_INITIAL = AK_USER_DEFINE_SIG,
	/* Signal Button Mode - Up - Down */
	AC_DISPLAY_BUTTON_MODE_RELEASED,
	AC_DISPLAY_BUTTON_UP_RELEASED,
	AC_DISPLAY_BUTTON_DOWN_RELEASED,
	/* Signal Button long */
	AC_DISPLAY_BUTTON_MODE_LONG_PRESSED,
	AC_DISPLAY_BUTTON_UP_LONG_PRESSED,
	AC_DISPLAY_BUTTON_DOWN_LONG_RELEASED,

	AC_DISPLAY_SHOW_LOGO,
	AC_DISPLAY_SHOW_IDLE,
	AC_DISPLAY_SHOW_IDLE_BALL_MOVING_UPDATE,
	AC_DISPLAY_SHOW_FW_UPDATE,
	AC_DISPLAY_SHOW_FW_UPDATE_ERR,

	AC_DISPLAY_SHOW_INFORM,
	AC_DISPLAY_SETTING_UPDATE,
	AC_DISPLAY_SHOW_LETTER,

};

/*****************************************************************************/
/* DBG task define
 */
/*****************************************************************************/
/* define timer */
/* define signal */
enum {
	AC_DBG_TEST_1 = AK_USER_DEFINE_SIG,
};

/*****************************************************************************/
/*  app function declare
 */
/*****************************************************************************/
#define APP_MAGIC_NUMBER	0xAABBCCDD
#define APP_VER				{0, 0, 0, 3}

typedef struct {
	uint32_t magic_number;
	uint8_t version[4];
} app_info_t;

extern const app_info_t app_info;

extern void* app_get_boot_share_data();
extern int  main_app();

#ifdef __cplusplus
}
#endif

#endif //__APP_H__
#include "task_list.h"
#include "timer.h"

const task_t app_task_table[] = {
	/*************************************************************************/
	/* SYSTEM TASK */
	/*************************************************************************/
	{TASK_TIMER_TICK_ID,		TASK_PRI_LEVEL_7,		task_timer_tick			},

	/*************************************************************************/
	/* APP TASK */
	/*************************************************************************/
	{AC_TASK_SYSTEM_ID			,	TASK_PRI_LEVEL_2	,	task_system			},
	{AC_TASK_FW_ID				,	TASK_PRI_LEVEL_2	,	task_fw				},
	{AC_TASK_SHELL_ID			,	TASK_PRI_LEVEL_2	,	task_shell			},
	{AC_TASK_LIFE_ID			,	TASK_PRI_LEVEL_6	,	task_life			},
	{AC_TASK_IF_ID				,	TASK_PRI_LEVEL_4	,	task_if				},
	{AC_TASK_UART_IF_ID			,	TASK_PRI_LEVEL_4	,	task_uart_if		},
	{AC_TASK_DBG_ID				,	TASK_PRI_LEVEL_4	,	task_dbg			},
	{AC_TASK_DISPLAY_ID			,	TASK_PRI_LEVEL_4	,	task_display		},

	/*************************************************************************/
	/* LINK TASK */
	/*************************************************************************/
	#if defined (IF_LINK_UART_EN)
	{AC_LINK_PHY_ID				,	TASK_PRI_LEVEL_3	,	task_link_phy		},
	{AC_LINK_MAC_ID				,	TASK_PRI_LEVEL_4	,	task_link_mac		},
	{AC_LINK_ID					,	TASK_PRI_LEVEL_5	,	task_link			},
	#endif

	/*************************************************************************/
	/* END OF TABLE */
	/*************************************************************************/
	{AK_TASK_EOT_ID				,	TASK_PRI_LEVEL_0	,	(pf_task)0			}
};

const task_polling_t app_task_polling_table[] = {
	{AC_TASK_POLLING_CONSOLE_ID	,	AK_ENABLE	,	task_polling_console		},
	{AK_TASK_POLLING_EOT_ID		,	AK_DISABLE	,	(pf_task_polling)0			},
};
#ifndef __TASK_LIST_H__
#define __TASK_LIST_H__

#include "ak.h"
#include "task.h"

extern const task_t app_task_table[];
extern const task_polling_t app_task_polling_table[];

/*****************************************************************************/
/*  DECLARE: Internal Task ID
 *  Note: Task id MUST be increasing order.
 */
/*****************************************************************************/
enum {
	/* SYSTEM TASKS */
	TASK_TIMER_TICK_ID,

	/* APP TASKS */
	AC_TASK_SYSTEM_ID,
	AC_TASK_FW_ID,
	AC_TASK_SHELL_ID,
	AC_TASK_LIFE_ID,
	AC_TASK_IF_ID,
	AC_TASK_UART_IF_ID,
	AC_TASK_DBG_ID,
	AC_TASK_DISPLAY_ID,

	/* LINK */
#if defined (IF_LINK_UART_EN)
	AC_LINK_PHY_ID,
	AC_LINK_MAC_ID,
	AC_LINK_ID,
#endif

	/* EOT task ID */
	AK_TASK_EOT_ID,
};

/*****************************************************************************/
/*  DECLARE: Internal Polling Task ID
 *  Note: Task id MUST be increasing order.
 */
/*****************************************************************************/
enum {
	/* APP TASKS */
	AC_TASK_POLLING_CONSOLE_ID,
	/* EOT polling task ID */
	AK_TASK_POLLING_EOT_ID,
};

/*****************************************************************************/
/*  DECLARE: Task entry point
 */
/*****************************************************************************/
/* APP TASKS */
extern void task_system(ak_msg_t*);
extern void task_fw(ak_msg_t*);
extern void task_shell(ak_msg_t*);
extern void task_life(ak_msg_t*);
extern void task_if(ak_msg_t*);
extern void task_uart_if(ak_msg_t*);
extern void task_dbg(ak_msg_t*);
extern void task_display(ak_msg_t*);

/* LINK TASK */
extern void task_link_phy(ak_msg_t*);
extern void task_link_mac(ak_msg_t*);
extern void task_link(ak_msg_t*);

/*****************************************************************************/
/*  DECLARE: Task polling
 */
/*****************************************************************************/
extern void task_polling_console();

#endif //__TASK_LIST_H__
#include "mw24_eeprom.h"

static uint8_t number_address_rf24	  = MW24_ADDRESS_RF24_MIN;
static uint8_t address_rf24[]		  = {0x3c, 0x3c, 0x3c, 0, 0};
static uint8_t channel_rf24			  = MW24_CHANNEL_RF24_MIN;
static uint8_t number_baudrate_modbus = (uint8_t)MB_BAUDRATE_2400;
static uint32_t baudrate_modbus		  = mw24_modbus_baudrate_array[(uint8_t)MB_BAUDRATE_2400];

uint8_t caculate_checksum(mw24_data_cfg_t *data) {
	uint8_t checksum	= 0;
	uint8_t *data_array = reinterpret_cast<uint8_t *>(data);

	for (size_t i = 0; i < sizeof(mw24_data_cfg_t); i++) {
		checksum += data_array[i];
	}

	return checksum;
}

bool mw24_set_data_cfg(mw24_data_cfg_t *data) {
	/****************************
 * Address nRF24l01*
 ****************************/
	/* check */
	if (data->address < MW24_ADDRESS_RF24_MIN || data->address > MW24_ADDRESS_RF24_MAX) {
		data->address = MW24_ADDRESS_RF24_MIN;
		// FATAL("RF", 0x01);
		return false;
	}
	/* set*/
	number_address_rf24 = data->address;
	address_rf24[3]		= ((data->address << 8) & 0xFF);
	address_rf24[4]		= (data->address & 0xFF);

	/****************************
 * Channel nRF24l01*
 ****************************/
	/* check */
	if (data->channel < MW24_CHANNEL_RF24_MIN || data->channel > MW24_CHANNEL_RF24_MAX) {
		data->channel = MW24_CHANNEL_RF24_MIN;
		// FATAL("RF", 0x02);
		return false;
	}
	/* set */
	channel_rf24 = data->channel;
	/****************************
 * Baudrate modbus *
 ****************************/
	/* check */
	if (data->number_baudrate < MW24_NUMBER_BAUDRATE_MODBUS_MIN || data->number_baudrate > MW24_NUMBER_BAUDRATE_MODBUS_MAX) {
		data->number_baudrate = MW24_NUMBER_BAUDRATE_MODBUS_MIN;
		// FATAL("RF", 0x03);
		return false;
	}
	/* set */
	number_baudrate_modbus = data->number_baudrate;
	baudrate_modbus = mw24_modbus_baudrate_array[(uint8_t)number_baudrate_modbus];

	return true;
}

uint8_t mw24_eeprom_read_data_cfg(mw24_data_cfg_t *data) {
	mw24_eeprom_data_t data_config;

	uint8_t read_data[SIZE_DATA_CONFIG];
	eeprom_read(MW24_EEPROM_DATA_CONFIG_ADDR, (uint8_t *)&read_data, SIZE_DATA_CONFIG);

	memcpy(&data_config, read_data, SIZE_DATA_CONFIG);

	if (data_config.magic_number != MW24_MAGIC_NUMBER_CFG_DATA) {
		return MW24_EEPROM_READ_DATA_FAIL;
	}

	if (data_config.checksum == caculate_checksum(&data_config.data)) {
		if(!mw24_set_data_cfg(&data_config.data)) {
			return MW24_EEPROM_READ_DATA_ERROR;
		}
		memcpy(data, &data_config.data, sizeof(mw24_data_cfg_t));
		return MW24_EEPROM_READ_DATA_SUCCESS;
	}
	return MW24_EEPROM_READ_DATA_ERROR;
}

uint8_t mw24_eeprom_write_data_cfg(mw24_data_cfg_t *data) {
	mw24_eeprom_data_t save_data;
	save_data.data		   = *data;
	save_data.magic_number = MW24_MAGIC_NUMBER_CFG_DATA;
	save_data.checksum	   = caculate_checksum(data);

	uint8_t byte[SIZE_DATA_CONFIG];
	memcpy(&byte, &save_data, SIZE_DATA_CONFIG);
	if (eeprom_write(MW24_EEPROM_DATA_CONFIG_ADDR, (uint8_t *)&byte, SIZE_DATA_CONFIG) == 0) {
		return MW24_EEPROM_WRITE_DATA_SUCCESS;
	}
	return MW24_EEPROM_WRITE_DATA_FAIL;
}

uint8_t mw24_get_number_address_nrf() {
	return number_address_rf24;
}

uint8_t *mw24_get_address_nrf() {
	return (uint8_t*)&address_rf24;
}

uint8_t mw24_get_channel_nrf() {
	return channel_rf24;
}

uint8_t mw24_get_number_baudrate_modbus() {
	return number_baudrate_modbus;
}

uint32_t mw24_get_baudrate_modbus() {
	return baudrate_modbus;
}
#ifndef __MW24_EEPROM_H__
#define __MW24_EEPROM_H__

#include <stdint.h>
#include "sys_dbg.h"
#include "eeprom.h"
#include "mw24_config.h"

/***********************************************************/
/* Read / write data */
/************************************************************/
#define MW24_MAGIC_NUMBER_CFG_DATA	 (0xAABBCCDD)
#define MW24_EEPROM_DATA_CONFIG_ADDR (0x0100)

#define SIZE_DATA_CONFIG			 (sizeof(mw24_eeprom_data_t))

typedef struct {
	uint8_t address;
	uint8_t channel;
	uint8_t number_baudrate;
	uint8_t null;
} mw24_data_cfg_t;

typedef struct {
	uint32_t magic_number;
	mw24_data_cfg_t data;
	uint8_t checksum;
} mw24_eeprom_data_t;

typedef enum mw24_modbus_baudrate_e {
	MB_BAUDRATE_2400,
	MB_BAUDRATE_4800,
	MB_BAUDRATE_9600,
	MB_BAUDRATE_14400,
	MB_BAUDRATE_19200,
	MB_BAUDRATE_28800,
	MB_BAUDRATE_38400,
	MB_BAUDRATE_57600,
	MB_BAUDRATE_76800,
	MB_BAUDRATE_115200
} mw24_modbus_baudrate_t;

const uint32_t mw24_modbus_baudrate_array[] = {2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 76800, 115200};

typedef enum mw24_eeprom_states_e {
	MW24_EEPROM_READ_DATA_SUCCESS,
	MW24_EEPROM_READ_DATA_FAIL,		// Wrong magic number
	MW24_EEPROM_READ_DATA_ERROR,	// Wrong checksum
	MW24_EEPROM_WRITE_DATA_SUCCESS,
	MW24_EEPROM_WRITE_DATA_FAIL
} mw24_eeprom_states_t;

extern uint8_t mw24_eeprom_write_data_cfg(mw24_data_cfg_t *data);
extern uint8_t mw24_eeprom_read_data_cfg(mw24_data_cfg_t *data);
extern bool mw24_set_data_cfg(mw24_data_cfg_t *data);

extern uint8_t mw24_get_number_address_nrf();
extern uint8_t *mw24_get_address_nrf();
extern uint8_t mw24_get_channel_nrf();
extern uint8_t mw24_get_number_baudrate_modbus();
extern uint32_t mw24_get_baudrate_modbus();

#endif //__MW24_EEPROM_H__
#include "mw24_io_cfg.h"
#include "mw24_eeprom.h"

/******************************************************************************
* nfr24l01 IO function
*******************************************************************************/
void mw24_io_nrf_ctrl_init() {
	/* CE / CSN / IRQ */
	GPIO_InitTypeDef        GPIO_InitStructure;
	EXTI_InitTypeDef        EXTI_InitStruct;
	NVIC_InitTypeDef        NVIC_InitStruct;

	/* GPIOA Periph clock enable */
	RCC_AHBPeriphClockCmd(NRF_CE_IO_CLOCK, ENABLE);
	RCC_AHBPeriphClockCmd(NRF_CSN_IO_CLOCK, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

	/*CE -> PA8*/
	GPIO_InitStructure.GPIO_Pin = NRF_CE_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
	GPIO_Init(NRF_CE_IO_PORT, &GPIO_InitStructure);

	/*CNS -> PB9*/
	GPIO_InitStructure.GPIO_Pin = NRF_CSN_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;

	GPIO_Init(NRF_CSN_IO_PORT, &GPIO_InitStructure);

	/* IRQ -> PB1 */
	GPIO_InitStructure.GPIO_Pin = NRF_IRQ_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_Init(NRF_IRQ_IO_PORT, &GPIO_InitStructure);

	SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOB, EXTI_PinSource1);

	EXTI_InitStruct.EXTI_Line = EXTI_Line1;
	EXTI_InitStruct.EXTI_LineCmd = ENABLE;
	EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
	EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Falling;
	EXTI_Init(&EXTI_InitStruct);

	NVIC_InitStruct.NVIC_IRQChannel = EXTI1_IRQn;
	NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 3;
	NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStruct);
}

/*****************************************************************************
 *SPI nRF24l01
******************************************************************************/
void mw24_spi_nrf_ctrl_init() {
	GPIO_InitTypeDef  GPIO_InitStructure;
	SPI_InitTypeDef   SPI_InitStructure;

	/*!< SPI GPIO Periph clock enable */
	RCC_AHBPeriphClockCmd(SPI_SCK_IO_CLOCK, ENABLE);

	/*!< SPI Periph clock enable */
	RCC_APB2PeriphClockCmd(SPI_NRF_CLOCK, ENABLE);

	/*!< Configure SPI pins: SCK */
	GPIO_InitStructure.GPIO_Pin = SPI_SCK_IO_PIN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_40MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_UP;
	GPIO_Init(SPI_SCK_IO_PORT, &GPIO_InitStructure);

	/*!< Configure SPI pins: MISO */
	GPIO_InitStructure.GPIO_Pin = SPI_MISO_IO_PIN;
	GPIO_Init(SPI_MISO_IO_PORT, &GPIO_InitStructure);

	/*!< Configure SPI pins: MOSI */
	GPIO_InitStructure.GPIO_Pin = SPI_MOSI_IO_PIN;
	GPIO_Init(SPI_MOSI_IO_PORT, &GPIO_InitStructure);

	/* Connect PXx to SPI_SCK */
	GPIO_PinAFConfig(SPI_SCK_IO_PORT, SPI_SCK_IO_SOURCE, SPI_NRF_GPIO);

	/* Connect PXx to SPI_MISO */
	GPIO_PinAFConfig(SPI_MISO_IO_PORT, SPI_MISO_IO_SOURCE, SPI_NRF_GPIO);

	/* Connect PXx to SPI_MOSI */
	GPIO_PinAFConfig(SPI_MOSI_IO_PORT, SPI_MOSI_IO_SOURCE, SPI_NRF_GPIO);

	/*!< SPI Config */
	SPI_DeInit(SPI_NRF);
	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;

	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
	SPI_InitStructure.SPI_CRCPolynomial = 7;
	SPI_Init(SPI_NRF, &SPI_InitStructure);

	SPI_Cmd(SPI_NRF, ENABLE); /*!< SPI enable */
}

void mw24_ce_nrf_low() {
	GPIO_ResetBits(NRF_CE_IO_PORT, NRF_CE_IO_PIN);
}

void mw24_ce_nrf_high() {
	GPIO_SetBits(NRF_CE_IO_PORT, NRF_CE_IO_PIN);
}

void mw24_csn_nrf_low() {
	GPIO_ResetBits(NRF_CSN_IO_PORT, NRF_CSN_IO_PIN);
}

void mw24_csn_nrf_high() {
	GPIO_SetBits(NRF_CSN_IO_PORT, NRF_CSN_IO_PIN);
}

uint8_t mw24_spi_nrf_rw(uint8_t data) {
	unsigned long rxtxData = data;
	uint32_t counter;

	/* waiting send idle then send data */
	counter = system_info.cpu_clock / 1000;
	while (SPI_I2S_GetFlagStatus(SPI_NRF, SPI_I2S_FLAG_TXE) == RESET) {
		if (counter-- == 0) {
			FATAL("spi", 0x01);
		}
	}

	SPI_I2S_SendData(SPI_NRF, (uint8_t)rxtxData);

	/* waiting conplete rev data */
	counter = system_info.cpu_clock / 1000;
	while (SPI_I2S_GetFlagStatus(SPI_NRF, SPI_I2S_FLAG_RXNE) == RESET) {
		if (counter-- == 0) {
			FATAL("spi", 0x02);
		}
	}

	rxtxData = (uint8_t)SPI_I2S_ReceiveData(SPI_NRF);

	return (uint8_t)rxtxData;
}

/*****************************************************************************
 *io uart for rs485
******************************************************************************/
void mw24_io_uart_rs485_cfg() {
	GPIO_InitTypeDef GPIO_InitStructure;
	NVIC_InitTypeDef NVIC_InitStructure;

	/* Enable GPIO clock */
	RCC_AHBPeriphClockCmd(USART_RS485_TX_GPIO_CLK | USART_RS485_RX_GPIO_CLK, ENABLE);

	/* Enable USART clock */
	RCC_APB1PeriphClockCmd(USART_RS485_CLK, ENABLE);

	/* Connect PXx to USART2_Tx */
	GPIO_PinAFConfig(USART_RS485_TX_GPIO_PORT, USART_RS485_TX_SOURCE, USART_RS485_TX_AF);

	/* Connect PXx to USART2_Rx */
	GPIO_PinAFConfig(USART_RS485_RX_GPIO_PORT, USART_RS485_RX_SOURCE, USART_RS485_RX_AF);

	/* Configure USART Tx and Rx as alternate function push-pull */
	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_AF;
	GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_InitStructure.GPIO_Pin		= USART_RS485_TX_PIN;
	GPIO_Init(USART_RS485_TX_GPIO_PORT, &GPIO_InitStructure);

	GPIO_InitStructure.GPIO_Pin		= USART_RS485_RX_PIN;
	GPIO_Init(USART_RS485_RX_GPIO_PORT, &GPIO_InitStructure);

	/* NVIC configuration */
	/* Configure the Priority Group to 4 bits */
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_4);
	NVIC_InitStructure.NVIC_IRQChannel = USART_RS485_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
}

void mw24_io_rs485_dir_mode_output() {
	GPIO_InitTypeDef GPIO_InitStructure;

	RCC_AHBPeriphClockCmd(RS485_DIR_IO_CLOCK, ENABLE);
	GPIO_InitStructure.GPIO_Mode	= GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType	= GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed	= GPIO_Speed_2MHz;
	GPIO_InitStructure.GPIO_Pin		= RS485_DIR_IO_PIN;
	GPIO_Init(RS485_DIR_IO_PORT, &GPIO_InitStructure);
}

void mw24_rs485_uart2_init() {

	USART_InitTypeDef USART_InitStructure;
	USART_ClockInitTypeDef USART_ClockInitStructure;

	ENTRY_CRITICAL();
	/* GPIO - Uart2 */
	mw24_io_uart_rs485_cfg();
	
	/* GPIO - rs485 tx/rx */
	mw24_io_rs485_dir_mode_output();

	/* rs485 rx */
	mw24_io_rs485_dir_low();

	/* USART2 configuration */
	USART_InitStructure.USART_BaudRate = mw24_get_baudrate_modbus();
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
	USART_InitStructure.USART_StopBits = USART_StopBits_1;
	USART_InitStructure.USART_Parity = USART_Parity_No;
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
	USART_Init(USART_RS485, &USART_InitStructure);

	/* Default other settings. */
	USART_ClockInitStructure.USART_Clock = USART_Clock_Disable;
	USART_ClockInitStructure.USART_CPOL = USART_CPOL_Low;
	USART_ClockInitStructure.USART_CPHA = USART_CPHA_2Edge;
	USART_ClockInitStructure.USART_LastBit = USART_LastBit_Disable;
	USART_ClockInit(USART_RS485, &USART_ClockInitStructure);

	USART_Cmd( USART_RS485, ENABLE );

	USART_ITConfig( USART_RS485, USART_IT_RXNE, ENABLE );
	USART_ITConfig( USART_RS485, USART_IT_TXE, DISABLE );

	EXIT_CRITICAL();
}

void mw24_tx_rs485_uart2_enable() {
	mw24_io_rs485_dir_high();
	USART_ITConfig( USART_RS485, USART_IT_TXE, ENABLE );
}

void mw24_tx_rs485_uart2_disable() {
	mw24_io_rs485_dir_low();
}

void mw24_io_rs485_dir_low() {
	GPIO_ResetBits(RS485_DIR_IO_PORT, RS485_DIR_IO_PIN);
}

void mw24_io_rs485_dir_high() {
	GPIO_SetBits(RS485_DIR_IO_PORT, RS485_DIR_IO_PIN);
}
#ifndef __MW24_IO_CFG_H__
#define __MW24_IO_CFG_H__

#include "stdint.h"
#include <stdbool.h>
#include "io_cfg.h"
#include "platform.h"
#include "sys_dbg.h"
#include "sys_ctrl.h"
#include "app_dbg.h"
#include "eeprom.h"
#include "system.h"

/*****************************************************************************
 *Pin map nRF24l01
******************************************************************************/
#define NRF_CE_IO_PIN					(GPIO_Pin_8)
#define NRF_CE_IO_PORT					(GPIOA)
#define NRF_CE_IO_CLOCK					(RCC_AHBPeriph_GPIOA)

#define NRF_CSN_IO_PIN					(GPIO_Pin_9)
#define NRF_CSN_IO_PORT					(GPIOB)
#define NRF_CSN_IO_CLOCK				(RCC_AHBPeriph_GPIOB)

#define NRF_IRQ_IO_PIN					(GPIO_Pin_1)
#define NRF_IRQ_IO_PORT					(GPIOB)
#define NRF_IRQ_IO_CLOCK				(RCC_AHBPeriph_GPIOB)

#define NRF_TIM						    (TIM6)
#define NRF_TIM_PERIPH				    (RCC_APB1Periph_TIM6)
#define NRF_TIM_IRQ					    (TIM6_IRQn)

/*****************************************************************************
 *SPI nRF24l01
******************************************************************************/
#define SPI_SCK_IO_PIN                  (GPIO_Pin_5)
#define SPI_SCK_IO_PORT                 (GPIOA)
#define SPI_SCK_IO_CLOCK                (RCC_AHBPeriph_GPIOA)
#define SPI_SCK_IO_SOURCE               (GPIO_PinSource5)

#define SPI_MISO_IO_PIN                 (GPIO_Pin_6)
#define SPI_MISO_IO_PORT                (GPIOA)
#define SPI_MISO_IO_CLOCK               (RCC_AHBPeriph_GPIOA)
#define SPI_MISO_IO_SOURCE              (GPIO_PinSource6)

#define SPI_MOSI_IO_PIN                 (GPIO_Pin_7)
#define SPI_MOSI_IO_PORT                (GPIOA)
#define SPI_MOSI_IO_CLOCK               (RCC_AHBPeriph_GPIOA)
#define SPI_MOSI_IO_SOURCE              (GPIO_PinSource7)

#define SPI_NRF                        (SPI1)
#define SPI_NRF_GPIO                   (GPIO_AF_SPI1)
#define SPI_NRF_CLOCK                  (RCC_APB2Periph_SPI1)

/****************************************************************************
 *UART RS485 - RS485 dir io config
*****************************************************************************/
#define USART_RS485						(USART2)
#define USART_RS485_CLK					(RCC_APB1Periph_USART2)
#define USART_RS485_IRQn				(USART2_IRQn)

#define USART_RS485_TX_PIN				(GPIO_Pin_3)
#define USART_RS485_TX_GPIO_PORT		(GPIOA)
#define USART_RS485_TX_GPIO_CLK			(RCC_AHBPeriph_GPIOA)
#define USART_RS485_TX_SOURCE			(GPIO_PinSource3)
#define USART_RS485_TX_AF				(GPIO_AF_USART2)

#define USART_RS485_RX_PIN				(GPIO_Pin_2)
#define USART_RS485_RX_GPIO_PORT		(GPIOA)
#define USART_RS485_RX_GPIO_CLK			(RCC_AHBPeriph_GPIOA)
#define USART_RS485_RX_SOURCE			(GPIO_PinSource2)
#define USART_RS485_RX_AF				(GPIO_AF_USART2)

#define RS485_TIM						(TIM4)
#define RS485_TIM_PERIPH				(RCC_APB1Periph_TIM4)
#define RS485_TIM_IRQ					(TIM4_IRQn)

/*RS485 dir IO*/
#define RS485_DIR_IO_PIN				(GPIO_Pin_1)
#define RS485_DIR_IO_PORT				(GPIOA)
#define RS485_DIR_IO_CLOCK				(RCC_AHBPeriph_GPIOA)

/*****************************************************************************
 *io uart for rs485-modbusRTU
******************************************************************************/
extern void mw24_io_uart_rs485_cfg();
extern void mw24_io_rs485_dir_mode_output();
extern void mw24_io_rs485_dir_low();
extern void mw24_io_rs485_dir_high();

extern void mw24_rs485_uart2_init();
extern void mw24_tx_rs485_uart2_enable();
extern void mw24_tx_rs485_uart2_disable();

#endif //__MW24_IO_CFG_H__
/* Copyright (c) 2006 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is confidential property of 
 * Nordic Semiconductor. The use, copying, transfer or disclosure of such
 * information is prohibited except by express written agreement with 
 * Nordic Semiconductor.
 */

/** @file
 * Implementation of #hal_nrf_rw.
 * #hal_nrf_rw is an SPI function which is hardware dependent. This file
 * contains an implementation for nRF24LU1.
 */


#include <stdint.h>

#include "hal_nrf.h"
#include "mw24_io_cfg.h"

uint8_t hal_nrf_rw(uint8_t value) {
	return mw24_spi_nrf_rw(value);
}

/** @file
 *
 * Header file defining hardware dependent functions for nRF24LU1.
 *
 * @addtogroup nordic_hal_nrf
 *
 * @{
 * @defgroup nordic_hal_nrf_hw nRF24L01 HW dependents.
 * @{
 *
 * $Rev: 1731 $
 *
 */

#ifndef _HAL_NRF_AK_H_
#define _HAL_NRF_AK_H_

#include "sys_ctrl.h"
#include "sys_io.h"

/** Macro that set radio's CSN line LOW.
 *
 */
#define CSN_LOW() do { mw24_csn_nrf_low(); } while(0)

/** Macro that set radio's CSN line HIGH.
 *
 */
#define CSN_HIGH() do { mw24_csn_nrf_high(); } while(0)

/** Macro that set radio's CE line LOW.
 *
 */
#define CE_LOW() do { mw24_ce_nrf_low(); } while(0)

/** Macro that set radio's CE line HIGH.
 *
 */
#define CE_HIGH() do { mw24_ce_nrf_high(); } while(0)

/**
 * Pulses the CE to nRF24L01 for at least 10 us
 */
#define CE_PULSE() do { \
  uint8_t count; \
  count = 20; \
  CE_HIGH();  \
  while(count--) \
    ; \
  CE_LOW();  \
  } while(0)

#endif

/** @} */
/** @} */

/* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is property of Nordic Semiconductor ASA.
 * Terms and conditions of usage are described in detail in NORDIC
 * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
 *
 * Licensees are granted free, non-transferable use of the information. NO
 * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
 * the file.
 *
 * $LastChangedRevision: 2132 $
 */ 

 /** @file
 *
 * @author Runar Kjellhaug
 *
 */

#include <stdint.h>
#include <stdbool.h>

#include "nordic_common.h"
#include "hal_nrf.h"
#include "hal_nrf_reg.h"

#define HAL_NRF_SET_BIT(pos) ((uint8_t) (1<<( (uint8_t) (pos) )))
#define UINT8(t) ((uint8_t) (t))

void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state)
{
  if(irq_state)
  {
	hal_nrf_write_reg(CONFIG, hal_nrf_read_reg(CONFIG) & ~HAL_NRF_SET_BIT(int_source));
  }
  else
  {
	hal_nrf_write_reg(CONFIG, hal_nrf_read_reg(CONFIG) | HAL_NRF_SET_BIT(int_source));
  }
}

uint8_t hal_nrf_get_clear_irq_flags(void)
{
  return hal_nrf_write_reg(STATUS, (BIT_6|BIT_5|BIT_4)) & (BIT_6|BIT_5|BIT_4);
}

void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source)
{
  hal_nrf_write_reg(STATUS, HAL_NRF_SET_BIT(int_source));
}
 
bool hal_nrf_get_irq_mode(uint8_t int_type)
{
  if(hal_nrf_read_reg(CONFIG) & HAL_NRF_SET_BIT(int_type))
    return false;
  else
    return true;
}

uint8_t hal_nrf_get_irq_flags(void)
{
  return hal_nrf_nop() & (BIT_6|BIT_5|BIT_4);
}

void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode)
{
  hal_nrf_write_reg(CONFIG, (hal_nrf_read_reg(CONFIG) & ~(BIT_3|BIT_2)) | (UINT8(crc_mode)<<2));
}

void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack)
{
  switch(pipe_num)
  {
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
    case HAL_NRF_PIPE2:
    case HAL_NRF_PIPE3:
    case HAL_NRF_PIPE4:
    case HAL_NRF_PIPE5:
	  hal_nrf_write_reg(EN_RXADDR, hal_nrf_read_reg(EN_RXADDR) | HAL_NRF_SET_BIT(pipe_num));

      if(auto_ack)
		hal_nrf_write_reg(EN_AA, hal_nrf_read_reg(EN_AA) | HAL_NRF_SET_BIT(pipe_num));
      else
		hal_nrf_write_reg(EN_AA, hal_nrf_read_reg(EN_AA) & ~HAL_NRF_SET_BIT(pipe_num));
      break;

    case HAL_NRF_ALL:
	  hal_nrf_write_reg(EN_RXADDR, ((uint8_t)~(BIT_7|BIT_6)));

      if(auto_ack)
		hal_nrf_write_reg(EN_AA, ((uint8_t)~(BIT_7|BIT_6)));
      else
        hal_nrf_write_reg(EN_AA, 0);
      break;
      
    default:
      break;
  }
}

void hal_nrf_close_pipe(hal_nrf_address_t pipe_num)
{
  switch(pipe_num)
  {
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
    case HAL_NRF_PIPE2:
    case HAL_NRF_PIPE3:
    case HAL_NRF_PIPE4:
    case HAL_NRF_PIPE5:
	  hal_nrf_write_reg(EN_RXADDR, hal_nrf_read_reg(EN_RXADDR) & ~HAL_NRF_SET_BIT(pipe_num));
	  hal_nrf_write_reg(EN_AA, hal_nrf_read_reg(EN_AA) & ~HAL_NRF_SET_BIT(pipe_num));
      break;
    
    case HAL_NRF_ALL:
      hal_nrf_write_reg(EN_RXADDR, 0);
      hal_nrf_write_reg(EN_AA, 0);
      break;
      
    default:
      break;
  }
}

void hal_nrf_set_address(hal_nrf_address_t address, uint8_t *addr)
{
  switch(address)
  {
    case HAL_NRF_TX:
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
      hal_nrf_write_multibyte_reg((uint8_t) address, addr, 0);
      break;

    case HAL_NRF_PIPE2:
    case HAL_NRF_PIPE3:
    case HAL_NRF_PIPE4:
    case HAL_NRF_PIPE5:
      hal_nrf_write_reg(RX_ADDR_P0 + (uint8_t) address, *addr);
      break;

    default:
      break;
  }
}

void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay)
{
  hal_nrf_write_reg(SETUP_RETR, (((delay/250)-1)<<4) | retr);
}

void hal_nrf_set_address_width(hal_nrf_address_width_t address_width)
{
  hal_nrf_write_reg(SETUP_AW, (UINT8(address_width) - 2));
}

void hal_nrf_set_rx_pload_width(uint8_t pipe_num, uint8_t pload_width)
{
  hal_nrf_write_reg(RX_PW_P0 + pipe_num, pload_width);
}

uint8_t hal_nrf_get_crc_mode(void)
{
  return (hal_nrf_read_reg(CONFIG) & (BIT_3|BIT_2)) >> CRCO;
}

uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num)
{
  uint8_t en_rx, en_aa;

  en_rx = hal_nrf_read_reg(EN_RXADDR) & (1<<pipe_num);
  en_aa = hal_nrf_read_reg(EN_AA) & (1<<pipe_num);

  en_rx >>= pipe_num;
  en_aa >>= pipe_num;

  return (en_aa << 1) + en_rx;
}

uint8_t hal_nrf_get_address(uint8_t address, uint8_t *addr)
{
  switch(address)
  {
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
    case HAL_NRF_TX:
      return hal_nrf_read_multibyte_reg(address, addr);

    default:
      *addr = hal_nrf_read_reg(RX_ADDR_P0 + address);
      return hal_nrf_get_address_width();
  }
}

uint8_t hal_nrf_get_auto_retr_status(void)
{
  return hal_nrf_read_reg(OBSERVE_TX);
}

uint8_t hal_nrf_get_packet_lost_ctr(void)
{
  return (hal_nrf_read_reg(OBSERVE_TX) & (BIT_7|BIT_6|BIT_5|BIT_4)) >> 4;
}

uint8_t hal_nrf_get_address_width(void)
{
  return (hal_nrf_read_reg(SETUP_AW) + 2);
}

uint8_t hal_nrf_get_rx_pload_width(uint8_t pipe_num)
{
  return hal_nrf_read_reg(RX_PW_P0 + pipe_num);
}

void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode)
{
  if(op_mode == HAL_NRF_PRX)
  {
    hal_nrf_write_reg(CONFIG, (hal_nrf_read_reg(CONFIG) | (1<<PRIM_RX)));
  }
  else
  {
    hal_nrf_write_reg(CONFIG, (hal_nrf_read_reg(CONFIG) & ~(1<<PRIM_RX)));
  }
}

void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode)
{
  if(pwr_mode == HAL_NRF_PWR_UP)
  {
    hal_nrf_write_reg(CONFIG, (hal_nrf_read_reg(CONFIG) | (1<<PWR_UP)));
  }
  else
  {
    hal_nrf_write_reg(CONFIG, (hal_nrf_read_reg(CONFIG) & ~(1<<PWR_UP)));
  }
}

void hal_nrf_set_rf_channel(uint8_t channel)
{
  hal_nrf_write_reg(RF_CH, channel);
}

void hal_nrf_set_output_power(hal_nrf_output_power_t power)
{
  hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) & ~((1<<RF_PWR1)|(1<<RF_PWR0))) | (UINT8(power)<<1));
}

void hal_nrf_set_datarate(hal_nrf_datarate_t datarate)
{
  if(datarate == HAL_NRF_1MBPS)
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) & ~(1<<RF_DR)));
  }
  else
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) | (1<<RF_DR)));
  }
}

uint8_t hal_nrf_get_operation_mode(void)
{
  return (hal_nrf_read_reg(CONFIG) & (1<<PRIM_RX)) >> PRIM_RX;
}

uint8_t hal_nrf_get_power_mode(void)
{
  return (hal_nrf_read_reg(CONFIG) & (1<<PWR_UP)) >> PWR_UP;
}

uint8_t hal_nrf_get_rf_channel(void)
{
  return hal_nrf_read_reg(RF_CH);
}

uint8_t hal_nrf_get_output_power(void)
{
  return (hal_nrf_read_reg(RF_SETUP) & ((1<<RF_PWR1)|(1<<RF_PWR0))) >> RF_PWR0;
}

uint8_t hal_nrf_get_datarate(void)
{
  return (hal_nrf_read_reg(RF_SETUP) & (1<<RF_DR)) >> RF_DR;
}

bool hal_nrf_rx_fifo_empty(void)
{
 if(hal_nrf_get_rx_data_source()==7)
  {
    return true;
  }
  else
  {
    return false;
  }
}

bool hal_nrf_rx_fifo_full(void)
{
  return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> RX_EMPTY) & 1);
}

bool hal_nrf_tx_fifo_empty(void)
{
  return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> TX_EMPTY) & 1);
}

bool hal_nrf_tx_fifo_full(void)
{
  return (bool)((hal_nrf_read_reg(FIFO_STATUS) >> TX_FIFO_FULL) & 1);
}

uint8_t hal_nrf_get_tx_fifo_status(void)
{
  return ((hal_nrf_read_reg(FIFO_STATUS) & ((1<<TX_FIFO_FULL)|(1<<TX_EMPTY))) >> 4);
}

uint8_t hal_nrf_get_rx_fifo_status(void)
{
  return (hal_nrf_read_reg(FIFO_STATUS) & ((1<<RX_FULL)|(1<<RX_EMPTY)));
}

uint8_t hal_nrf_get_fifo_status(void)
{
  return hal_nrf_read_reg(FIFO_STATUS);
}

uint8_t hal_nrf_get_transmit_attempts(void)
{
  return hal_nrf_read_reg(OBSERVE_TX) & (BIT_3|BIT_2|BIT_1|BIT_0);
}

bool hal_nrf_get_carrier_detect(void)
{
  return hal_nrf_read_reg(CD) & 1;
}

void hal_nrf_write_tx_pload(uint8_t *tx_pload, uint8_t length)
{
  hal_nrf_write_multibyte_reg(UINT8(HAL_NRF_TX_PLOAD), tx_pload, length);
}

void hal_nrf_setup_dyn_pl(uint8_t setup)
{
  hal_nrf_write_reg(DYNPD, setup & ~0xC0); 
}

void hal_nrf_enable_dynamic_pl(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) | 0x04));   
}

void hal_nrf_disable_dynamic_pl(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) & ~0x04));   
}

void hal_nrf_enable_ack_pl(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) | 0x02));   
}

void hal_nrf_disable_ack_pl(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) & ~0x02));   
}

void hal_nrf_enable_dynamic_ack(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) | 0x01));   
}

void hal_nrf_disable_dynamic_ack(void)
{
  hal_nrf_write_reg(FEATURE, (hal_nrf_read_reg(FEATURE) & ~0x01));   
}

void hal_nrf_write_ack_pload(uint8_t pipe, uint8_t *tx_pload, uint8_t length)
{
  CSN_LOW();

  hal_nrf_rw(WR_ACK_PLOAD | pipe);
  while(length--)
  {
    hal_nrf_rw(*tx_pload++);
  }

  CSN_HIGH();
}

uint8_t hal_nrf_read_rx_pl_w()
{
  uint8_t temp;
  
  CSN_LOW();

  hal_nrf_rw(RD_RX_PLOAD_W);
  temp = hal_nrf_rw(0);
  CSN_HIGH();

  return temp;
}

void hal_nrf_lock_unlock()
{
  CSN_LOW();

  hal_nrf_rw(LOCK_UNLOCK);             
  hal_nrf_rw(0x73);

  CSN_HIGH();
}

uint8_t hal_nrf_get_rx_data_source(void)
{
  return ((hal_nrf_nop() & (BIT_3|BIT_2|BIT_1)) >> 1);
}

// Fixed: returns length==0 and pipe==7 means FIFO empty

uint16_t hal_nrf_read_rx_pload(uint8_t *rx_pload)
{
  return hal_nrf_read_multibyte_reg(UINT8(HAL_NRF_RX_PLOAD), rx_pload);
}

void hal_nrf_reuse_tx(void)
{
  hal_nrf_write_reg(REUSE_TX_PL, 0);
}

bool hal_nrf_get_reuse_tx_status(void)
{
  return (bool)((hal_nrf_get_fifo_status() & (1<<TX_REUSE)) >> TX_REUSE);
}

void hal_nrf_flush_rx(void)
{
  hal_nrf_write_reg(FLUSH_RX, 0);
}

void hal_nrf_flush_tx(void)
{
  hal_nrf_write_reg(FLUSH_TX, 0);
}

uint8_t hal_nrf_nop(void)
{
  return hal_nrf_write_reg(NOP,0);
}

void hal_nrf_set_pll_mode(hal_nrf_pll_mode_t pll_mode)
{
  if(pll_mode == HAL_NRF_PLL_LOCK)
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) | (1<<PLL_LOCK)));
  }
  else
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) & ~(1<<PLL_LOCK)));
  }
}

hal_nrf_pll_mode_t hal_nrf_get_pll_mode(void)
{
  return (hal_nrf_pll_mode_t)((hal_nrf_read_reg(RF_SETUP) & (1<<PLL_LOCK)) >> PLL_LOCK);
}

void hal_nrf_set_lna_gain(hal_nrf_lna_mode_t lna_gain)
{
  if(lna_gain == HAL_NRF_LNA_HCURR)
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) | (1<<LNA_HCURR)));
  }
  else
  {
    hal_nrf_write_reg(RF_SETUP, (hal_nrf_read_reg(RF_SETUP) & ~(1<<LNA_HCURR)));
  }
}

hal_nrf_lna_mode_t hal_nrf_get_lna_gain(void)
{
  return (hal_nrf_lna_mode_t) ( (hal_nrf_read_reg(RF_SETUP) & (1<<LNA_HCURR)) >> LNA_HCURR );
}

uint8_t hal_nrf_read_reg(uint8_t reg)
{
uint8_t temp;
  CSN_LOW();
  hal_nrf_rw(reg);
  temp = hal_nrf_rw(0);
  CSN_HIGH();

  return temp;
}

uint8_t hal_nrf_write_reg(uint8_t reg, uint8_t value)
{
  uint8_t retval;
  CSN_LOW();
  if(reg < WRITE_REG_CMD)   // i.e. this is a register access
  {
	retval = hal_nrf_rw(WRITE_REG_CMD + reg);
    hal_nrf_rw(value);
  }
  else            // single byte cmd OR future command/register access
  {
    if(!(reg == FLUSH_TX) && !(reg == FLUSH_RX) && !(reg == REUSE_TX_PL) && !(reg == NOP))
    {
      retval = hal_nrf_rw(reg);
      hal_nrf_rw(value);
    }
    else          // single byte L01 command
    {
      retval = hal_nrf_rw(reg);
    }
  }
  CSN_HIGH();

  return retval;
}

uint16_t hal_nrf_read_multibyte_reg(uint8_t reg, uint8_t *pbuf)
{
uint8_t ctr, length;
  switch(reg)
  {
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
    case HAL_NRF_TX:
      length = ctr = hal_nrf_get_address_width();
      CSN_LOW();
      hal_nrf_rw(RX_ADDR_P0 + reg);
      break;
      
    case HAL_NRF_RX_PLOAD:
      if( (reg = hal_nrf_get_rx_data_source()) < 7)
      {
        length = ctr = hal_nrf_read_rx_pl_w();

        CSN_LOW();
        hal_nrf_rw(RD_RX_PLOAD);
      }
      else
      {
       ctr = length = 0;
      }
      break;

    default:
      ctr = length = 0;
      break;
  }

  while(ctr--)
  {
    *pbuf++ = hal_nrf_rw(0);
  }

  CSN_HIGH();

  return (((uint16_t) reg << 8) | length);
}

void hal_nrf_write_multibyte_reg(uint8_t reg, uint8_t *pbuf, uint8_t length)
{
  switch(reg)
  {
    case HAL_NRF_PIPE0:
    case HAL_NRF_PIPE1:
    case HAL_NRF_TX:
      length = hal_nrf_get_address_width();
      CSN_LOW();
	  hal_nrf_rw(WRITE_REG_CMD + RX_ADDR_P0 + reg);
      break;
      
    case HAL_NRF_TX_PLOAD:
      CSN_LOW();
      hal_nrf_rw(WR_TX_PLOAD);
      break;      
    default:
      break;
  }

  while(length--)
  {
    hal_nrf_rw(*pbuf++);
  }

  CSN_HIGH();
}
/* Copyright (c) 2006 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is confidential property of Nordic Semiconductor. The use,
 * copying, transfer or disclosure of such information is prohibited except by express written
 * agreement with Nordic Semiconductor.
 *
 * $Rev: 1731 $
 *
 */

/** @file
 * Register definitions for the nRF HAL module
 * @defgroup nordic_hal_nrf_reg nRF24L01 Register definitions
 * @{
 * @ingroup nordic_hal_nrf
 * Header file defining register mapping with bit definitions.\ This file is radio-chip dependent, and are included with the hal_nrf.h
 */

#ifndef HAL_NRF_REG_H__
#define HAL_NRF_REG_H__

/** @name - Instruction Set - */
//@{
/* nRF24L01 Instruction Definitions */
#define WRITE_REG_CMD	0x20 /**< Register write command */
#define RD_RX_PLOAD_W	0x60 /**< Read RX payload command */
#define RD_RX_PLOAD		0x61 /**< Read RX payload command */
#define WR_TX_PLOAD		0xA0 /**< Write TX payload command */
#define WR_ACK_PLOAD	0xA8 /**< Write ACK payload command */
#define WR_NAC_TX_PLOAD 0xB0 /**< Write ACK payload command */
#define FLUSH_TX		0xE1 /**< Flush TX register command */
#define FLUSH_RX		0xE2 /**< Flush RX register command */
#define REUSE_TX_PL		0xE3 /**< Reuse TX payload command */
#define LOCK_UNLOCK		0x50 /**< Lock/unlcok exclusive features */

#define NOP				0xFF /**< No Operation command, used for reading status register */
//@}

/** @name  - Register Memory Map - */
//@{
/* nRF24L01 * Register Definitions * */
#define CONFIG        0x00  /**< nRF24L01 config register */
#define EN_AA         0x01  /**< nRF24L01 enable Auto-Acknowledge register */
#define EN_RXADDR     0x02  /**< nRF24L01 enable RX addresses register */
#define SETUP_AW      0x03  /**< nRF24L01 setup of address width register */
#define SETUP_RETR    0x04  /**< nRF24L01 setup of automatic retransmission register */
#define RF_CH         0x05  /**< nRF24L01 RF channel register */
#define RF_SETUP      0x06  /**< nRF24L01 RF setup register */
#define STATUS        0x07  /**< nRF24L01 status register */
#define OBSERVE_TX    0x08  /**< nRF24L01 transmit observe register */
#define CD            0x09  /**< nRF24L01 carrier detect register */
#define RX_ADDR_P0    0x0A  /**< nRF24L01 receive address data pipe0 */
#define RX_ADDR_P1    0x0B  /**< nRF24L01 receive address data pipe1 */
#define RX_ADDR_P2    0x0C  /**< nRF24L01 receive address data pipe2 */
#define RX_ADDR_P3    0x0D  /**< nRF24L01 receive address data pipe3 */
#define RX_ADDR_P4    0x0E  /**< nRF24L01 receive address data pipe4 */
#define RX_ADDR_P5    0x0F  /**< nRF24L01 receive address data pipe5 */
#define TX_ADDR       0x10  /**< nRF24L01 transmit address */
#define RX_PW_P0      0x11  /**< nRF24L01 \# of bytes in rx payload for pipe0 */
#define RX_PW_P1      0x12  /**< nRF24L01 \# of bytes in rx payload for pipe1 */
#define RX_PW_P2      0x13  /**< nRF24L01 \# of bytes in rx payload for pipe2 */
#define RX_PW_P3      0x14  /**< nRF24L01 \# of bytes in rx payload for pipe3 */
#define RX_PW_P4      0x15  /**< nRF24L01 \# of bytes in rx payload for pipe4 */
#define RX_PW_P5      0x16  /**< nRF24L01 \# of bytes in rx payload for pipe5 */
#define FIFO_STATUS   0x17  /**< nRF24L01 FIFO status register */
#define DYNPD         0x1C  /**< nRF24L01 Dynamic payload setup */
#define FEATURE       0x1D  /**< nRF24L01 Exclusive feature setup */

//@}

/* nRF24L01 related definitions */
/* Interrupt definitions */
/* Operation mode definitions */

/** An enum describing the radio's irq sources.
 *
 */
typedef enum {
    HAL_NRF_MAX_RT = 4,     /**< Max retries interrupt */
    HAL_NRF_TX_DS,          /**< TX data sent interrupt */
    HAL_NRF_RX_DR           /**< RX data received interrupt */
} hal_nrf_irq_source_t;

/* Operation mode definitions */
/** An enum describing the radio's power mode.
 *
 */
typedef enum {
    HAL_NRF_PTX,            /**< Primary TX operation */
    HAL_NRF_PRX             /**< Primary RX operation */
} hal_nrf_operation_mode_t;

/** An enum describing the radio's power mode.
 *
 */
typedef enum {
    HAL_NRF_PWR_DOWN,       /**< Device power-down */
    HAL_NRF_PWR_UP          /**< Device power-up */
} hal_nrf_pwr_mode_t;

/** An enum describing the radio's output power mode's.
 *
 */
typedef enum {
    HAL_NRF_18DBM,          /**< Output power set to -18dBm */
    HAL_NRF_12DBM,          /**< Output power set to -12dBm */
    HAL_NRF_6DBM,           /**< Output power set to -6dBm  */
    HAL_NRF_0DBM            /**< Output power set to 0dBm   */
} hal_nrf_output_power_t;

/** An enum describing the radio's on-air datarate.
 *
 */
typedef enum {
    HAL_NRF_1MBPS,          /**< Datarate set to 1 Mbps  */
    HAL_NRF_2MBPS           /**< Datarate set to 2 Mbps  */
} hal_nrf_datarate_t;

/** An enum describing the radio's PLL mode.
 *
 */
typedef enum {
    HAL_NRF_PLL_UNLOCK,     /**< PLL unlocked, normal operation  */
    HAL_NRF_PLL_LOCK        /**< PLL locked, test mode  */
} hal_nrf_pll_mode_t;

/** An enum describing the radio's LNA mode.
 *
 */
typedef enum {
    HAL_NRF_LNA_LCURR,      /**< LNA set to low current mode */
    HAL_NRF_LNA_HCURR       /**< LNA set to high current mode */
} hal_nrf_lna_mode_t;

/** An enum describing the radio's CRC mode.
 *
 */
typedef enum {
    HAL_NRF_CRC_OFF,        /**< CRC check disabled */
    HAL_NRF_CRC_8BIT = 2,   /**< CRC check set to 8-bit */
    HAL_NRF_CRC_16BIT       /**< CRC check set to 16-bit */
} hal_nrf_crc_mode_t;

/** An enum describing the read/write payload command.
 *
 */
typedef enum {
    HAL_NRF_TX_PLOAD = 7,   /**< TX payload definition */
    HAL_NRF_RX_PLOAD,        /**< RX payload definition */
    HAL_NRF_ACK_PLOAD
} hal_nrf_pload_command_t;

/** An enum describing the nRF24L01 pipe addresses and TX address.
 *
 */
typedef enum {
    HAL_NRF_PIPE0,              /**< Select pipe0 */
    HAL_NRF_PIPE1,              /**< Select pipe1 */
    HAL_NRF_PIPE2,              /**< Select pipe2 */
    HAL_NRF_PIPE3,              /**< Select pipe3 */
    HAL_NRF_PIPE4,              /**< Select pipe4 */
    HAL_NRF_PIPE5,              /**< Select pipe5 */
    HAL_NRF_TX,                 /**< Refer to TX address*/
    HAL_NRF_ALL = 0xFF          /**< Close or open all pipes*/
                                /**< @see hal_nrf_set_address @see hal_nrf_get_address
                                 @see hal_nrf_open_pipe  @see hal_nrf_close_pipe */
} hal_nrf_address_t;

/** An enum describing the radio's address width.
 *
 */
typedef enum {
    HAL_NRF_AW_3BYTES = 3,      /**< Set address width to 3 bytes */
    HAL_NRF_AW_4BYTES,          /**< Set address width to 4 bytes */
    HAL_NRF_AW_5BYTES           /**< Set address width to 5 bytes */
} hal_nrf_address_width_t;


/** @name CONFIG register bit definitions */
//@{

#define MASK_RX_DR    6     /**< CONFIG register bit 6 */
#define MASK_TX_DS    5     /**< CONFIG register bit 5 */
#define MASK_MAX_RT   4     /**< CONFIG register bit 4 */
#define EN_CRC        3     /**< CONFIG register bit 3 */
#define CRCO          2     /**< CONFIG register bit 2 */
#define PWR_UP        1     /**< CONFIG register bit 1 */
#define PRIM_RX       0     /**< CONFIG register bit 0 */
//@}

/** @name RF_SETUP register bit definitions */
//@{
#define PLL_LOCK      4     /**< RF_SETUP register bit 4 */
#define RF_DR         3     /**< RF_SETUP register bit 3 */
#define RF_PWR1       2     /**< RF_SETUP register bit 2 */
#define RF_PWR0       1     /**< RF_SETUP register bit 1 */
#define LNA_HCURR     0     /**< RF_SETUP register bit 0 */
//@}

/* STATUS 0x07 */
/** @name STATUS register bit definitions */
//@{
#define RX_DR         6     /**< STATUS register bit 6 */
#define TX_DS         5     /**< STATUS register bit 5 */
#define MAX_RT        4     /**< STATUS register bit 4 */
#define TX_FULL       0     /**< STATUS register bit 0 */
//@}

/* FIFO_STATUS 0x17 */
/** @name FIFO_STATUS register bit definitions */
//@{
#define TX_REUSE      6     /**< FIFO_STATUS register bit 6 */
#define TX_FIFO_FULL  5     /**< FIFO_STATUS register bit 5 */
#define TX_EMPTY      4     /**< FIFO_STATUS register bit 4 */
#define RX_FULL       1     /**< FIFO_STATUS register bit 1 */
#define RX_EMPTY      0     /**< FIFO_STATUS register bit 0 */
//@}

#endif // HAL_NRF_REG_H__
/** @} */
/* Copyright (c) 2007 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is property of Nordic Semiconductor ASA.
 * Terms and conditions of usage are described in detail in NORDIC
 * SEMICONDUCTOR STANDARD SOFTWARE LICENSE AGREEMENT. 
 *
 * Licensees are granted free, non-transferable use of the information. NO
 * WARRENTY of ANY KIND is provided. This heading must NOT be removed from
 * the file.
 *
 * $LastChangedRevision: 2132 $
 */ 

/** @file
 * Interface for nRF HAL
 * @defgroup nordic_hal_nrf nRF HAL
 * @{
 * @ingroup nordic_hal
 * HAL interface for Nordic Semiconductor's radio chip.
 */

#ifndef HAL_NRF_H__
#define HAL_NRF_H__

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint.h>
#include <stdbool.h>

#include "hal_nrf_reg.h"
#include "hal_nrf_hw.h"


/** @name  << SETUP FUNCTIONS >> */
//@{
/* Setup function prototypes */

/** Enable or disable interrupt for radio.
 * Use this function to enable or disable
 * one of the interrupt sources for the radio.
 * This function only changes state for selected
 * int_type, the rest of the interrupt sources
 * are left unchanged.
 *
 * @param int_source Radio interrupt Source.
 * @param irq_state Enable or Disable.
*/
void hal_nrf_set_irq_mode(hal_nrf_irq_source_t int_source, bool irq_state);

/** Activate features
 * Sends the ACTIVATE command to the RF tranceiver. By calling this function
 * once it is possible to use the functions related to the FEATURE register.  
 */
void hal_nrf_lock_unlock(void);

/** Enables the ACK payload feature
 */
void hal_nrf_enable_ack_pl(void);

/** Disables the ACK payload feature
 */
void hal_nrf_disable_ack_pl(void);

/** Enables the dynamic payload feature
 */
void hal_nrf_enable_dynamic_pl(void);

/** Disables the dynamic payload feature
 */
void hal_nrf_disable_dynamic_pl(void);

/** Sets the dynamic payload features for the RX pipes
* The input parameter contains is a byte where the bit values tells weather the
*  pipe uses the ack payload feature or not. For example if bit 0 is set then 
* Pipe 0 uses ack payload,
 * @param setup Byte value with bit set for pipes that uses the dynamic payload feature
 */
void hal_nrf_setup_dyn_pl(uint8_t setup);

/** Reads the payload width of the received ack payload
 * @return Payload width of the received ack payload
 */
uint8_t hal_nrf_read_rx_pl_w(void);

/** Write ack payload
 * Writes the payload that will be transmitted with the ack on the given pipe.
 * @param pipe Pipe that transmits the payload
 * @param tx_pload Pointer to the payload data
 * @param length Size of the data to transmit
 */
void hal_nrf_write_ack_pload(uint8_t pipe, uint8_t *tx_pload, uint8_t length);

/** Enables the no-ack feature
 */
void hal_nrf_enable_dynamic_ack(void);

/** Disables the no-ack feature
 */
void hal_nrf_disable_dynamic_ack(void);

/** Read then clears all interrupt flags.
 * Use this function to get the interrupt flags and clear them in the same operation.
 * Reduced radio interface activity and speed optimized.
 *
 * @return  Interrupt_flags
 * @retval 0x10 Max Retransmit interrupt
 * @retval 0x20 TX Data sent interrupt
 * @retval 0x40 RX Data received interrupt
*/
uint8_t hal_nrf_get_clear_irq_flags(void);

/** Clear one selected interrupt flag.
 * Use this function to clear one @a spesific interrupt flag.
 * Other interrupt flags are left unchanged.
 *
 * @param int_source Interrupt source of which flag to clear
*/
void hal_nrf_clear_irq_flag(hal_nrf_irq_source_t int_source);

/** Set the CRC mode used by the radio.
 * Use this function to set the CRC mode; CRC disabled, 1 or 2 bytes.
 *
 * @param crc_mode CRC mode to use
*/
void hal_nrf_set_crc_mode(hal_nrf_crc_mode_t crc_mode);

/** Open radio pipe(s) and enable/ disable auto acknowledge.
 * Use this function to open one or all pipes,
 * with or without auto acknowledge.
 *
 * @param pipe_num Radio pipe to open
 * @param auto_ack Auto_Ack ON/OFF
 * @see hal_nrf_address
*/
void hal_nrf_open_pipe(hal_nrf_address_t pipe_num, bool auto_ack);

/** Close radio pipe(s).
 * Use this function to close one pipe or all pipes.
 *
 * @param pipe_num Pipe# number to close
*/
void hal_nrf_close_pipe(hal_nrf_address_t pipe_num);

/** Set radio's RX address and TX address.
 * Use this function to set a RX address, or to set the TX address.
 * Beware of the difference for single and multibyte address registers.
 *
 * @param address Which address to set
 * @param *addr Buffer from which the address is stored in
*/
void hal_nrf_set_address(hal_nrf_address_t address, uint8_t *addr);

/** Set auto acknowledge parameters.
 * Use this function to set retransmit and retransmit delay
 * parameters.
 *
 * @param retr Number of retransmit, 0 equ retransmit OFF
 * @param delay Retransmit delay in �s
*/
void hal_nrf_set_auto_retr(uint8_t retr, uint16_t delay);

/** Set radio's address width.
 * Use this function to define the radio's address width,
 * referes to both RX and TX.
 *
 * @param address_width Address with in bytes
*/
void hal_nrf_set_address_width(hal_nrf_address_width_t address_width);

/** Set payload width for selected pipe.
 * Use this function to set the number of bytes expected
 * on a selected pipe.
 *
 * @param pipe_num Pipe number to set payload width for
 * @param pload_width number of bytes expected
*/
void hal_nrf_set_rx_pload_width(uint8_t pipe_num, uint8_t pload_width);

/** Read current interrupt mode for selected interrupt source.
 * Use this function to get the interrupt source's mode,
 * either enabled or disabled.
 *
 * @param int_source Interrupt source to get mode from
 *
 * @return Interrupt Mode
 * @retval FALSE Interrupt disabled
 * @retval TRUE Interrupt enabled
*/
bool hal_nrf_get_irq_mode(uint8_t int_source);

/** Read all interrupt flags.
 * Use this function to get the interrupt flags. This function is similar
 * to hal_nrf_get_clear_irq_flags with the exception that it does <I><B>NOT</B></I> clear
 * the irq_flags.
 *
 * @return Interrupt_flags
 * @retval 0x10 Max Retransmit interrupt
 * @retval 0x20 TX Data sent interrupt
 * @retval 0x40 RX Data received interrupt
*/
uint8_t hal_nrf_get_irq_flags(void);

/** Get CRC mode.
 * Use this function to check which CRC mode is used.
 *
 * @return CRC_mode
 * @retval 0x00 CRC_OFF
 * @retval 0x02 CRC_8BIT
 * @retval 0x03 CRC_16BIT
*/
uint8_t hal_nrf_get_crc_mode(void);

/** Get pipe status.
 * Use this function to check status for a selected pipe.
 *
 * @param  pipe_num Pipe number to check status for
 *
 * @return Pipe_Status
 * @retval 0x00 Pipe is closed, autoack disabled
 * @retval 0x01 Pipe is open, autoack disabled
 * @retval 0x03 Pipe is open, autoack enabled
*/
uint8_t hal_nrf_get_pipe_status(uint8_t pipe_num);

/** Get address for selected pipe.
 * Use this function to get address for selected pipe.
 *
 *
 * @param address Which address to get, Pipe- or TX-address
 * @param *addr buffer in which address bytes are written.
 * <BR><BR>For pipes containing only LSB byte of address, this byte is returned
 * in the<BR> *addr buffer.
 *
 * @return Address_Width in bytes
*/
uint8_t hal_nrf_get_address(uint8_t address, uint8_t *addr);

/** Get auto retransmit parameters.
 * Use this function to get the auto retransmit parameters,
 * retrans count and retrans delay.
 *
 * @return AutoRetrans Parameters
 *
 * @retval UpperNibble Retransmit Delay
 * @retval LowerNibble Retransmit Count
*/
uint8_t hal_nrf_get_auto_retr_status(void);

/** Get packet lost counter
 * Use this function to get the packet(s) counter.
 *
 * @return packet lost counter
*/
uint8_t hal_nrf_get_packet_lost_ctr(void);

/** Get address width for radio.
 * Use this function to get the address width used for
 * the radio, both RX and TX.
 *
 * @return Address_Width in bytes
*/
uint8_t hal_nrf_get_address_width(void);

/** Get RX payload width for selected pipe.
 * Use this function to get the expected payload
 * width for selected ppe number.
 *
 * @param pipe_num Pipe number to get payload width for
 *
 * @return Payload_Width in bytes
*/
uint8_t hal_nrf_get_rx_pload_width(uint8_t pipe_num);
//@}

/** @name  << OPERATION FUNCTIONS >> */
//@{
/* Operation function prototypes */

/** Set radio's operation mode.
 * Use this function to enter PTX (primary TX)
 * or PRX (primary RX).
 *
 * @param op_mode Operation mode
*/
void hal_nrf_set_operation_mode(hal_nrf_operation_mode_t op_mode);

/** Set radio's power mode.
 * Use this function to power_up or power_down radio.
 *
 * @param pwr_mode POWER_UP or POWER_DOWN
*/
void hal_nrf_set_power_mode(hal_nrf_pwr_mode_t pwr_mode);

/** Set radio's RF channel.
 * Use this function to select which RF channel to use.
 *
 * @param channel RF channel
*/
void hal_nrf_set_rf_channel(uint8_t channel);

/** Set radio's TX output power.
 * Use this function set the radio's TX output power.
 *
 * @param power Radio's TX output power
*/
void hal_nrf_set_output_power(hal_nrf_output_power_t power);

/** Set radio's on-air datarate.
 * Use this function to select radio's on-air
 * datarate.
 *
 * @param datarate On-air datarate
*/
void hal_nrf_set_datarate(hal_nrf_datarate_t datarate);

/** Get radio's current operation mode.
 * Use this function to get the radio's current
 * operation mode, PTX or PRX.
 *
 * @return Operation_Mode
 * @retval 0x00 Primary RX (PRX)
 * @retval 0x01 Primary TX (PTX)
*/
uint8_t hal_nrf_get_operation_mode(void);

/** Get radio's current power mode.
 * Use this function to get the radio's currnet
 * power mode, POWER_UP or POWER_DOWN.
 *
 * @return Power_Mode
 * @retval 0x00 POWER_DOWN
 * @retval 0x01 POWER_UP
*/
uint8_t hal_nrf_get_power_mode(void);

/** Get radio's current RF channel.
 * Use this function to get the radio's current
 * selected RF channel
 *
 * @return RF channel
*/
uint8_t hal_nrf_get_rf_channel(void);

/** Get radio's current TX output power.
 * Use this function to get the radio's current
 * TX output power setting.
 *
 * @return TX_power_output
 * @retval 0x00 -18dBm
 * @retval 0x01 -12dBm
 * @retval 0x02 -6dBm
 * @retval 0x03 0dBm
*/
uint8_t hal_nrf_get_output_power(void);

/** Get radio's current on-air datarate.
 * Use this function to get the radio's current
 * on-air datarate setting.
 *
 * @return On-air datarate
 * @retval 0x00 1Mbps selected
 * @retval 0x01 2Mbps selected
*/
uint8_t hal_nrf_get_datarate(void);

/* Status functions prototypes */

/** Get radio's TX FIFO status.
 * Use this function to get the radio's TX
 * FIFO status.
 *
 * @return TX FIFO status
 * @retval 0x00 TX FIFO NOT empty, but NOT full
 * @retval 0x01 FIFO empty
 * @retval 0x02 FIFO full
 *
*/
uint8_t hal_nrf_get_tx_fifo_status(void);

/** Check for TX FIFO empty.
 * Use this function to check if TX FIFO
 * is empty.
 *
 * @return TX FIFO empty bit
 * @retval FALSE TX FIFO NOT empty
 * @retval TRUE TX FIFO empty
 *
*/
bool hal_nrf_tx_fifo_empty(void);

/** Check for TX FIFO full.
 * Use this function to check if TX FIFO
 * is full.
 *
 * @return TX FIFO full bit
 * @retval FALSE TX FIFO NOT full
 * @retval TRUE TX FIFO full
 *
*/
bool hal_nrf_tx_fifo_full(void);

/** Get radio's RX FIFO status.
 * Use this function to get the radio's TX
 * FIFO status.
 *
 * @return RX FIFO status
 * @retval 0x00 RX FIFO NOT empty, but NOT full
 * @retval 0x01 RX FIFO empty
 * @retval 0x02 RX FIFO full
 *
*/
uint8_t hal_nrf_get_rx_fifo_status(void);

/** Check for RX FIFO empty.
 * Use this function to check if RX FIFO
 * is empty.
 *
 * Reads STATUS register to check this, not FIFO_STATUS  
 *
 * @return RX FIFO empty bit
 * @retval FALSE RX FIFO NOT empty
 * @retval TRUE RX FIFO empty
 *
*/
bool hal_nrf_rx_fifo_empty(void);

/** Check for RX FIFO full.
 * Use this function to check if RX FIFO
 * is full.
 *
 * @return RX FIFO full bit
 * @retval FALSE RX FIFO NOT full
 * @retval TRUE RX FIFO full
 *
*/
bool hal_nrf_rx_fifo_full(void);

/** Get radio's transmit attempts status.
 * Use this function to get number of retransmit
 * attempts and number of packet lost.
 *
 * @return Retransmit attempts counters
*/
uint8_t hal_nrf_get_transmit_attempts(void);

/** Get the carrier detect flag.
 * Use this function to get the carrier detect flag,
 * used to detect stationary disturbance on selected
 * RF channel.
 *
 * @return Carrier Detect
 * @retval FALSE Carrier NOT Detected
 * @retval TRUE Carrier Detected
*/
bool hal_nrf_get_carrier_detect(void);

/* Data operation prototypes */

/** Get RX data source.
 * Use this function to read which RX pipe data
 * was received on for current top level FIFO data packet.
 *
 * @return pipe number of current packet present
*/
uint8_t hal_nrf_get_rx_data_source(void);

/** Read RX payload.
 * Use this function to read top level payload
 * available in the RX FIFO.
 *
 * @param  *rx_pload pointer to buffer in which RX payload are stored
 * @return pipe number (MSB byte) and packet length (LSB byte)
*/
uint16_t hal_nrf_read_rx_pload(uint8_t *rx_pload);

/** Write TX payload to radio.
 * Use this function to write a packet of
 * TX payload into the radio.
 * <I>length</I> number of bytes, which are stored in <I>*tx_pload</I>.
 *
 * @param *tx_pload pointer to buffer in which TX payload are present
 * @param length number of bytes to write
*/
void hal_nrf_write_tx_pload(uint8_t *tx_pload, uint8_t length);

/** Reuse TX payload.
 * Use this function to set that the radio is using
 * the last transmitted payload for the next packet as well.
 *
*/
void hal_nrf_reuse_tx(void);

/** Get status of reuse TX function.
 * Use this function to check if reuse TX payload is
 * activated
 *
 * @return Reuse TX payload mode
 * @retval FALSE Not activated
 * @retval TRUE Activated
*/
bool hal_nrf_get_reuse_tx_status(void);

/** Flush RX FIFO.
 * Use this function to flush the radio's
 * RX FIFO.
 *
*/
void hal_nrf_flush_rx(void);

/** Flush TX FIFO.
 * Use this function to flush the radio's
 * TX FIFO.
 *
*/
void hal_nrf_flush_tx(void);

/** No Operation command.
 * Use this function to receive the radio's
 * status register.
 *
 * @return Status register
*/
uint8_t hal_nrf_nop(void);
//@}

/** @name  << TEST FUNCTIONS >> */
//@{
/* Test functions prototypes */

/** Set radio's PLL mode.
 * Use this function to either LOCK
 * or UNLOCK the radio's PLL.
 *
 * @param pll_mode PLL locked, TRUE or FALSE
*/
void hal_nrf_set_pll_mode(hal_nrf_pll_mode_t pll_mode);

/** Get PLL mode.
 * Use this function to get the radio's
 * current PLL mode.
 *
 * @return PLL_mode
*/
hal_nrf_pll_mode_t hal_nrf_get_pll_mode(void);

/** Set radio's LNA gain mode.
 * Use this function to either use HI
 * current or LOW current mode for the radio.
 *
 * @param lna_gain LNA gain mode
*/
void hal_nrf_set_lna_gain(hal_nrf_lna_mode_t lna_gain);

/** Get LNA gain mode.
 * Use this function to get the radio's
 * current LNA gain mode.
 *
 * @return LNA gain mode
 * @retval 0 LNA LOW current
 * @retval 1 LNA HI current
*/
hal_nrf_lna_mode_t hal_nrf_get_lna_gain(void);

/* hal_nrf_l01 basic functions, used by all the other functions */

//@}

/** @name  << BASIS FUNCTIONS >> */
//@{

/** Basis function read_reg.
 * Use this function to read the contents
 * of one radios register.
 *
 * @param reg Register to read
 * @return Register contents
*/
uint8_t hal_nrf_read_reg(uint8_t reg);

/** Basis function write_reg.
 * Use this function to write a new value to
 * a radio register.
 *
 * @param reg Register to write
 * @param value New value to write
 * @return Status register
*/
uint8_t hal_nrf_write_reg(uint8_t reg, uint8_t value);

/** Basis function, read_multibyte register .
 * Use this function to read multiple bytes from
 * a multibyte radio-register
 *
 * @param reg Multibyte register to read from
 * @param *pbuf Pointer to buffer in which to store read bytes to
 *
 * @return pipe# of received data (MSB), if operation used by a hal_nrf_read_rx_pload
 * @return length of read data (LSB), either for hal_nrf_read_rx_pload or
 * for hal_nrf_get_address.
*/
uint16_t hal_nrf_read_multibyte_reg(uint8_t reg, uint8_t *pbuf);

/** Basis function, write_multibyte register.
 * Use this function to write multiple bytes to
 * a multiple radio register.
 *
 * @param reg Register to write
 * @param *pbuf pointer to buffer in which data to write is
 * @param length \# of bytes to write
*/
void hal_nrf_write_multibyte_reg(uint8_t reg, uint8_t *pbuf, uint8_t length);


/** Basis function, nrf_rw
 * This function is used by the basis functions
 * to exchange data with the data.
 *
 * @param value Databyte to write
 *
 * @return Databyte from radio.
*/
uint8_t hal_nrf_rw(uint8_t value);

#ifdef __cplusplus
}
#endif

//@}
#endif // HAL_NRF_H__
/** 
@} 
@} */

/* Copyright (c) 2006 Nordic Semiconductor. All Rights Reserved.
 *
 * The information contained herein is confidential property of Nordic Semiconductor. The use,
 * copying, transfer or disclosure of such information is prohibited except by express written
 * agreement with Nordic Semiconductor.
 */

/** @file
 * Common defines and macros for firmware developed by Nordic Semiconductor.
 *
 * @author Ken A. Redergaard
 */

#ifndef NORDIC_COMMON_H__
#define NORDIC_COMMON_H__

/** Swaps the upper byte with the lower byte in a 16 bit variable */
//lint -emacro((572),SWAP) // Suppress warning 572 "Excessive shift value"
#define SWAP(x) ((((x)&0xFF)<<8)|(((x)>>8)&0xFF))

/** The upper 8 bits of a 16 bit value */
#define MSB(a) ((a & 0xFF00) >> 8)
/** The lower 8 bits (of a 16 bit value) */
#define LSB(a) ((a & 0xFF))

/** Leaves the minimum of the two arguments */
#define MIN(a, b) ((a) < (b) ? (a) : (b))
/** Leaves the maximum of the two arguments */
#define MAX(a, b) ((a) < (b) ? (b) : (a))

#define BIT_0 0x01 /**< The value of bit 0 */
#define BIT_1 0x02 /**< The value of bit 1 */
#define BIT_2 0x04 /**< The value of bit 2 */
#define BIT_3 0x08 /**< The value of bit 3 */
#define BIT_4 0x10 /**< The value of bit 4 */
#define BIT_5 0x20 /**< The value of bit 5 */
#define BIT_6 0x40 /**< The value of bit 6 */
#define BIT_7 0x80 /**< The value of bit 7 */

#endif // NORDIC_COMMON_H__
#ifndef __MW24_CONFIG_H__
#define __MW24_CONFIG_H__

#define MW24_ADDRESS_RF24_MIN			(1)
#define MW24_ADDRESS_RF24_MAX			(5)

#define MW24_CHANNEL_RF24_MIN			(120)
#define MW24_CHANNEL_RF24_MAX			(125)

#define MW24_NUMBER_BAUDRATE_MODBUS_MIN (MB_BAUDRATE_2400)
#define MW24_NUMBER_BAUDRATE_MODBUS_MAX (MB_BAUDRATE_9600)

#endif //__MW24_CONFIG_H__
#ifndef __MW24_DEBUG_H__
#define __MW24_DEBUG_H__

/******************************************************************************
 * DEBUG
*******************************************************************************/
/* SET DEBUG - IO */
#define MW24_DEBUG_TX_EN		0
#define MW24_DEBUG_RX_EN		0
#define MW24_DEBUG_IRQ_EN		0

/* SET DEBUG - CONSOLE */
#define MW24_DEBUG_FLAGS_EN		0
#define MW24_DEBUG_DATA_EN		0
#define MW24_DEBUG_STATUS_EN	0

/******************************************************************************
 * DEBUG - IO
*******************************************************************************/
#if (MW24_DEBUG_TX_EN == 1)
#define MW24_DEBUG_TX_ON() do { mw24_tx_on(); } while (0)
#else
#define MW24_DEBUG_TX_ON()
#endif

#if (MW24_DEBUG_TX_EN == 1)
#define MW24_DEBUG_TX_OFF() do { mw24_tx_off(); } while (0)
#else
#define MW24_DEBUG_TX_OFF()
#endif

#if (MW24_DEBUG_RX_EN == 1)
#define MW24_DEBUG_RX_ON() do { mw24_rx_on(); } while (0)
#else
#define MW24_DEBUG_RX_ON()
#endif

#if (MW24_DEBUG_RX_EN == 1)
#define MW24_DEBUG_RX_OFF() do { mw24_rx_off(); } while (0)
#else
#define MW24_DEBUG_RX_OFF()
#endif

#if (MW24_DEBUG_IRQ_EN == 1)
#define MW24_DEBUG_IRQ_ON() /*do {  } while (0)*/
#else
#define MW24_DEBUG_IRQ_ON()
#endif

#if (MW24_DEBUG_IRQ_EN == 1)
#define MW24_DEBUG_IRQ_OFF() /*do {  } while (0)*/
#else
#define MW24_DEBUG_IRQ_OFF()
#endif

/******************************************************************************
 * DEBUG - CONSOLE
*******************************************************************************/
#if (MW24_DEBUG_FLAGS_EN == 1)
#define MW24_DEBUG_FLAGS(fmt, ...)            xprintf("RF-FLAGS-> " fmt, ##__VA_ARGS__)
#else
#define MW24_DEBUG_FLAGS(fmt, ...)
#endif

#if (MW24_DEBUG_DATA_EN == 1)
#define MW24_DEBUG_DATA(fmt, ...)             xprintf("RF-DATA-> " fmt, ##__VA_ARGS__)
#else
#define MW24_DEBUG_DATA(fmt, ...)
#endif

#if (MW24_DEBUG_STATUS_EN == 1)
#define MW24_DEBUG_STATUS(fmt, ...)           xprintf("RF-STATUS-> " fmt, ##__VA_ARGS__)
#else
#define MW24_DEBUG_STATUS(fmt, ...)
#endif

#endif //__MW24_DEBUG_H__
#include "mw24_nwk.h"
#include "mw24_eeprom.h"

/*************************************************************************************/
/* Variable and Struct Declaration */
/*************************************************************************************/
#define MW24_NRF_MAX_RETRANMIT		  ((1 << HAL_NRF_MAX_RT))
#define MW24_NRF_SEND_DONE			  ((1 << HAL_NRF_TX_DS))
#define MW24_NRF_PACKET_RECEIVED	  ((1 << HAL_NRF_RX_DR))
#define MW24_NRF_ACK_PAYLOAD_RECIEVED ((1 << HAL_NRF_RX_DR) | (1 << HAL_NRF_TX_DS))

/* Mode check wireless */
uint16_t mw24_check_wireless_msg_couter = 0;
bool mw24_i_enable_check_wireless = false;
bool mw24_i_am_master = false;

/* nrf state handware */
static uint8_t mw24_nrf_handware_state = MW24_NRF_HANDWARE_STATE_NONE;
static uint8_t mw24_get_nrf_handware_state();
static void mw24_set_nrf_handware_state(uint8_t state);

/* nrf state send */
static uint8_t mw24_nrf_send_state = MW24_NRF_SEND_STATE_IDLE;
static uint8_t mw24_get_nrf_send_state();
static void mw24_set_nrf_send_state(uint8_t state);

/* nrf state receive*/
static uint8_t mw24_nrf_recv_state = MW24_NRF_RECV_STATE_IDLE;
static uint8_t mw24_get_nrf_recv_state();
static void mw24_set_nrf_recv_state(uint8_t state);

/*************************************************************************************/
/* Action timer:
	1) mw24_end_sending: Update status and mode switch Rx*/
/*************************************************************************************/
void mw24_end_sending() {
	if (mw24_get_nrf_send_state() == MW24_NRF_SEND_STATE_SENDING) {
		mw24_set_nrf_send_state(MW24_NRF_SEND_STATE_IDLE);
		mw24_rx_nrf_mode_switch();
	}
	
	if (mw24_get_nrf_recv_state() == MW24_NRF_RECV_STATE_RECEIVING) {
		mw24_set_nrf_recv_state(MW24_NRF_SEND_STATE_IDLE);
		mw24_io_rs485_dir_low();
	}
}

/*************************************************************************************/
/* Action nRF24l01:
	1) mw24_tx_nrf_mode_switch: Switches the device to transmit (Tx) mode in nRF24l01.
	2) mw24_rx_nrf_mode_switch: Switches the device to receive (Rx) mode in nRF24l01.
	3) mw24_nrf_send_data_byte: Writes data to the transmit (Tx) register in nRF24l01.
	4) mw24_send_data_uart_to_nrf: Transfers data directly from UART to in nRF24l01.
	5) mw24_send_data_check_wireless: Sends data to check the wireless connectivity.
*/
/*************************************************************************************/
void mw24_tx_nrf_mode_switch() {
	CE_LOW();
	hal_nrf_set_operation_mode(HAL_NRF_PTX);
	sys_ctrl_delay_us(150);
	CE_HIGH();
}

void mw24_rx_nrf_mode_switch() {
	CE_LOW();
	hal_nrf_set_address(HAL_NRF_PIPE0, (uint8_t*)mw24_get_address_nrf()); /* Sets recieving address on pipe0 */
	hal_nrf_set_operation_mode(HAL_NRF_PRX);
	sys_ctrl_delay_us(150);
	CE_HIGH();
}

void mw24_nrf_send_data_byte(uint8_t* data, uint8_t len) {

	MW24_DEBUG_DATA("Data_send: [%d]\n", *data);

	/* off rf24 */
	CSN_LOW();
	/* Write command */
	hal_nrf_rw(WR_TX_PLOAD);
	/* Write tx_payload*/
	while (len--)
	{
		hal_nrf_rw(*data++);
	}
	/* On rf24 */
	CSN_HIGH();
}

void mw24_send_data_to_rf24_tx(uint8_t data) {
	if (mw24_get_nrf_handware_state() == MW24_NRF_HANDWARE_STATE_NONE) {
		return;
	}

	MW24_DEBUG_TX_ON();

	if (mw24_get_nrf_send_state() == MW24_NRF_SEND_STATE_IDLE) {
		mw24_tx_nrf_mode_switch();

		/* Enable timer change mode */
		mw24_timer_reset();
		mw24_timer_enable();
	}

	/* Clear data Tx */
	hal_nrf_flush_tx();

	/* Send data rf24*/
	mw24_nrf_send_data_byte((uint8_t*)&data, sizeof(data));

	/* update status rf24 */
	mw24_set_nrf_send_state(MW24_NRF_SEND_STATE_SENDING);

	MW24_DEBUG_TX_OFF();
}

void mw24_send_data_check_wireless() {
	uint8_t data = 7;
	if (mw24_get_nrf_handware_state() == MW24_NRF_HANDWARE_STATE_NONE) {
		return;
	}
	
	if (mw24_get_nrf_send_state() == MW24_NRF_SEND_STATE_IDLE) {
		mw24_tx_nrf_mode_switch();

		/* Enable timer change mode */
		mw24_timer_reset();
		mw24_timer_enable();
	}

	/* Clear data Tx */
	hal_nrf_flush_tx();

	/* Send data rf24*/
	mw24_nrf_send_data_byte((uint8_t*)&data, sizeof(data));

	/* update status rf24 */
	mw24_set_nrf_send_state(MW24_NRF_SEND_STATE_SENDING);
}

/*************************************************************************************/
/* Interrup nRF24l01 */
/*************************************************************************************/
void mw24_irq_nrf() {
	if (mw24_get_nrf_handware_state() == MW24_NRF_HANDWARE_STATE_NONE) {
		return;
	}

	uint8_t nrf24_irq_mask = hal_nrf_get_clear_irq_flags();
	MW24_DEBUG_FLAGS("RF24_flags: [%d]", nrf24_irq_mask);
	
	switch (nrf24_irq_mask) {
	case MW24_NRF_MAX_RETRANMIT: {
		MW24_DEBUG_STATUS("RF24_state_send: max retranmit\n");
		hal_nrf_flush_tx(); // clear tx
		mw24_rx_nrf_mode_switch(); // chuyen che do
	}
		break;

	case MW24_NRF_SEND_DONE: { /* send done */
		MW24_DEBUG_STATUS("RF24_state_send: send done\n");
		MW24_DEBUG_TX_ON();
		mw24_timer_reset(); /* reset timer change mode rf24 */
		MW24_DEBUG_TX_OFF();
	}
		break;

	case MW24_NRF_PACKET_RECEIVED: /* Packet received */
		MW24_DEBUG_STATUS("RF24_state_received: data_rf24\n");
		MW24_DEBUG_RX_ON();
		/* test connect */
		if (mw24_i_enable_check_wireless) {
			if (mw24_i_am_master == false) {
				mw24_check_wireless_msg_couter++;
			}
		}
		
		if (!hal_nrf_rx_fifo_empty()) {
			/* Receive data */
			uint8_t pl_len;
			volatile uint8_t k;
			pl_len = hal_nrf_read_rx_pload((uint8_t*)&k);

			if (pl_len != MW24_FRAME_DATA_RF24_PAYLOAD_LEN) {
				FATAL("RF24", 0x05);
			}

			MW24_DEBUG_RX_OFF();

			/* Clear data rx*/
			hal_nrf_flush_rx();

			MW24_DEBUG_RX_ON();

			/* Transformation mode rs485 -> Tx */
			// mw24_tx_rs485_uart2_enable();
			if (mw24_get_nrf_recv_state() == MW24_NRF_RECV_STATE_IDLE) {
				mw24_timer_reset();
				mw24_io_rs485_dir_high();
				mw24_timer_enable();
				mw24_set_nrf_recv_state(MW24_NRF_RECV_STATE_RECEIVING);
			}
			
			mw24_timer_reset();
			USART_SendData(USART2, k);

			MW24_DEBUG_RX_OFF();
		}
		break;

	case MW24_NRF_ACK_PAYLOAD_RECIEVED: { /* Ack payload recieved */
	}
		break;

	default: {
		hal_nrf_get_clear_irq_flags();
	}
		break;
	}
}

/*************************************************************************************/
/* Init nRF24l01 */
/*************************************************************************************/
void mw24_nrf_init() {
	/* init io control of nrf24 (CE, NCS, IRQ) */
	mw24_io_nrf_ctrl_init();
	/* init SPI1 */
	mw24_spi_nrf_ctrl_init();

	CE_LOW();
	sys_ctrl_delay_ms(100);

	hal_nrf_set_power_mode(HAL_NRF_PWR_DOWN);
	hal_nrf_get_clear_irq_flags();

	hal_nrf_close_pipe(HAL_NRF_ALL); /* First close all radio pipes, Pipe 0 and 1 open by default */
	hal_nrf_open_pipe(HAL_NRF_PIPE0, false); /* Open pipe0, without/autoack (autoack) */

	hal_nrf_set_crc_mode(HAL_NRF_CRC_8BIT); /* Operates in 16bits CRC mode */
	// hal_nrf_set_auto_retr(2, 750); /* Enable auto retransmit */

	hal_nrf_set_address_width(HAL_NRF_AW_5BYTES); /* 5 bytes address width */
	hal_nrf_set_address(HAL_NRF_TX, (uint8_t*)mw24_get_address_nrf()); /* Set device's addresses */
	hal_nrf_set_address(HAL_NRF_PIPE0, (uint8_t*)mw24_get_address_nrf()); /* Sets recieving address on pipe0 */

	hal_nrf_set_operation_mode(HAL_NRF_PRX);
	hal_nrf_set_rx_pload_width((uint8_t)HAL_NRF_PIPE0, MW24_FRAME_DATA_RF24_PAYLOAD_LEN);

	hal_nrf_set_rf_channel(mw24_get_channel_nrf());
	hal_nrf_set_output_power(HAL_NRF_0DBM);
	hal_nrf_set_lna_gain(HAL_NRF_LNA_HCURR);
	hal_nrf_set_datarate(HAL_NRF_2MBPS);

	hal_nrf_set_power_mode(HAL_NRF_PWR_UP); /* Power up device */

	hal_nrf_set_irq_mode(HAL_NRF_MAX_RT, true);
	hal_nrf_set_irq_mode(HAL_NRF_TX_DS, true);
	hal_nrf_set_irq_mode(HAL_NRF_RX_DR, true);

	hal_nrf_flush_rx();
	hal_nrf_flush_tx();

	sys_ctrl_delay_ms(2);
	CE_HIGH();

	ENTRY_CRITICAL();
	mw24_set_nrf_handware_state(MW24_NRF_HANDWARE_STATE_STARTED);
	mw24_set_nrf_send_state(MW24_NRF_SEND_STATE_IDLE);
	EXIT_CRITICAL();
}

/*************************************************************************************/
/* Status nRF24l01 */
/*************************************************************************************/
/* Status RF24 */
uint8_t mw24_get_nrf_handware_state() {
	return mw24_nrf_handware_state;
}

uint8_t mw24_get_nrf_send_state() {
	return mw24_nrf_send_state;
}

uint8_t mw24_get_nrf_recv_state() {
	return mw24_nrf_recv_state;
}

void mw24_set_nrf_handware_state(uint8_t state) {
	mw24_nrf_handware_state = state;
	MW24_DEBUG_STATUS("RF24_state_handware: [%d]\n", state);
}

void mw24_set_nrf_send_state(uint8_t state) {
	mw24_nrf_send_state = state;
	MW24_DEBUG_STATUS("RF24_state_send: [%d]\n", state);
}

void mw24_set_nrf_recv_state(uint8_t state) {
	mw24_nrf_recv_state = state;
	MW24_DEBUG_STATUS("RF24_state_recv: [%d]\n", state);
}
#ifndef __MW24_NWK_H__
#define __MW24_NWK_H__

/***********************************************************************************/
/* Library */
/***********************************************************************************/
#include <stdbool.h>
#include <stdint.h>

/* App */
#include "app.h"
#include "app_dbg.h"
#include "app_data.h"

/* task */
#include "task_list.h"

/* Sources ak*/
#include "fsm.h"
#include "port.h"
#include "message.h"
#include "timer.h"

/* System debug - interrup - io */
#include "sys_dbg.h"
#include "sys_irq.h"
#include "sys_io.h"

/* Buffer data */
#include "fifo.h"
#include "ring_buffer.h"

/* Hardware Abstraction Layer */
#include "hal_nrf.h"
#include "hal_nrf_hw.h"
#include "hal_nrf_reg.h"

/* Modbus wireless */
#include "io_cfg.h"
#include "mw24_io_cfg.h"
#include "mw24_timer.h"
#include "mw24_config.h"
#include "mw24_debug.h"

/***********************************************************************************/
/* Parameters */
/***********************************************************************************/
#define MW24_FRAME_DATA_MODBUS_MAX_LEN		(256)
#define MW24_FRAME_DATA_RF24_PAYLOAD_LEN	(1)
#define MW24_BUFFER_LENGHT					(256)

extern bool mw24_i_am_master;
extern bool mw24_i_enable_check_wireless;
extern uint16_t mw24_check_wireless_msg_couter;

/***********************************************************************************/
/* Status function */
/***********************************************************************************/
enum mw24_nrf_handware_state_e {
	MW24_NRF_HANDWARE_STATE_NONE,
	MW24_NRF_HANDWARE_STATE_STARTED,
};

enum mw24_nrf_send_state_e {
	MW24_NRF_SEND_STATE_IDLE,
	MW24_NRF_SEND_STATE_SENDING,
};

enum mw24_nrf_recv_state_e {
	MW24_NRF_RECV_STATE_IDLE,
	MW24_NRF_RECV_STATE_RECEIVING,
};

/***********************************************************************************/
/* nRF24l01 */
/***********************************************************************************/
/* init nRF24l01 */
extern void mw24_nrf_init();

/* action nRF24l01 */
extern void mw24_tx_nrf_mode_switch();
extern void mw24_rx_nrf_mode_switch();
extern void mw24_nrf_send_data_byte(uint8_t* data, uint8_t len);

#endif //__MW24_NWK_H__
#include "mw24_timer.h"
#include "xprintf.h"
#include "mw24_config.h"
/************************************************************************************
 * Timer 6 - timer
*************************************************************************************/
#define MW24_TIMEOUT_SEND_RECV			(3) /* ms */

static uint32_t timer_counter = 0;
static uint32_t timer_time_out;

void mw24_timer_init() {
	TIM_TimeBaseInitTypeDef  timer_10us;
	NVIC_InitTypeDef NVIC_InitStructure;
	timer_time_out = MW24_TIMEOUT_SEND_RECV;

	/* timer 10ms to polling receive IR signal */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);
	timer_10us.TIM_Period = 3196;		/* HCLK=8Mhz and 3196 respective HCLK=32Mhz;*/
	timer_10us.TIM_Prescaler = 10;
	timer_10us.TIM_ClockDivision = 0;
	timer_10us.TIM_CounterMode = TIM_CounterMode_Down;

	TIM_TimeBaseInit(TIM6, &timer_10us);

	NVIC_InitStructure.NVIC_IRQChannel = TIM6_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;	/* highest priority level */
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);

	TIM_ITConfig(TIM6, TIM_IT_Update, ENABLE);
	TIM_Cmd(TIM6, DISABLE);
}

void mw24_timer_increase_counter() {
	/* counter */
	timer_counter++;
	if (timer_counter == timer_time_out) {
		TIM_Cmd(TIM6, DISABLE);
		MW24_DEBUG_TX_ON();
		mw24_end_sending();
		MW24_DEBUG_TX_OFF();
	}
}

void mw24_timer_reset() {
	ENTRY_CRITICAL();
	timer_counter = 0;
	EXIT_CRITICAL();
}

void mw24_timer_enable() {
	ENTRY_CRITICAL();
	TIM_Cmd(TIM6, ENABLE);
	EXIT_CRITICAL();
}

void mw24_timer_disable() {
	ENTRY_CRITICAL();
	TIM_Cmd(TIM6, DISABLE);
	EXIT_CRITICAL();
}
#ifndef __MW24_TIMER_H__
#define __MW24_TIMER_H__

#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h>

#include "sys_cfg.h"
#include "system.h"

#include "stm32l1xx.h"
#include "stm32l1xx_conf.h"
#include "system_stm32l1xx.h"
#include "core_cm3.h"
#include "core_cmFunc.h"

#include "xprintf.h"
#include "ring_buffer.h"

#include "sys_dbg.h"
#include "sys_ctrl.h"
#include "sys_io.h"
#include "sys_dbg.h"
#include "ak.h"

#include "mw24_nwk.h"

#endif //__MW24_TIMER_H__
